## 3장 HTTP 메시지

HTTP가 인터넷의 배달원이라면, HTTP 메시지는 무언가를 담아 보내는 소포와 같다.

### 3.1 메세지의 흐름

-   HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들이다. 이 데이터의 블록들은 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음에 선택적으로 데이터가 올 수 있다.
-   HTTP 트랜잭션에서 메세지는 서버방향(인바운드)으로 이동후 모든 처리가 끝나면 사용자 에이전트방향(아웃바운드)로 돌아온다.
-   모든 HTTP 메세지는 요청 메세지냐 응답 메세지냐에 관계없이 다운스트림으로 흐른다.


### 3.2 메세지의 각 부분

- 시작줄 : 이것이 어떤 메세지인지 서술
- 헤더 : 메세지의 속성
	- content-type : 본문이 무엇인지
	- Content-length : 본문의 크기
- 본문 : 데이터

시작줄과 헤더는 줄 단위(CRLF)로 분리된 아스키 문자열이며, 본문은 텍스트나 이진 데이터를 포함하거나 비어있을 수 있다.

- 모든 HTTP는 요청 메세지나 응답 메세지로 분류된다.
- 요청 메세지는 명령과 URL을 포함한다.
	- {메서드} {요청URL} {버전}
	- {헤더}
	- {엔티티 본문}
- 응답 메세지는 트랜잭션 결과를 포함한다.
	- {버전} {상태코드} {사유 구절}
	- {헤더}
	- {엔티티 본문}

- 메서드
	- HEAD, GET, POST : 클라이언트에서 서버가 리소스에 수행해주기바라는 동작
	- 요청 URL : 리소스 위치
	- 버전 : 사용중인 HTTP 버전 HTTP / {메이저}, {마이너}
	- 상태코드 : 요청중에 무엇이 일어났는지 설명하는 세 자리 숫자 200 400 500
	- 사유구절(reason-phrase) : 상태코드의 의미를 설명해주는 문구 , 오로지 사람의 이해를 돕기 위한 목적으로만 사용된다.
	- 헤더들 : 이름, : , 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들. CRLF가 헤더목록의 끝과 엔티티 본문의 시작을 표시한다. 몇몇 버전의 HTTP는 요청이나 응답에 특정 헤더가 포함되어야만 유효한 것으로 간주한다.
	- 엔티티 본문 : 임의의 데이터 블록을 포함하며 비어있을 수 있다. 이때는 항상 CRLF로 끝나야한다.

- 시작줄
	- 요청메세지의 시작줄 : 무엇을 해야하는지.
	- 응답메세지의 시작줄 : 무슨일이 일어났는지.
		- 요청줄 :
			- 서버에서 어떤 동작이 일어나야하는지.
			- 그 동작에 대한 대상을 지칭하는 URL.
			- 클라이언트가 어떤 HTTP 버전으로 말하고 있는지.
			- 이 모든 필드는 공백으로 구분된다.
		- 응답줄 :
			- 수행 결과에 대한 상태 정보와 결과 데이터를 돌려준다.
			- 응답 메세지에 쓰인 HTTP버전, 숫자로된 상태코드, 수행 상태를 설명해주는 사유 구절
			- 이 모든 필드는 공백으로 구분된다.
		- 메서드 :
			- GET: 서버에서 어떤 문서를 가져온다.
			- HEAD: 어떤 문서에 대한 헤더만 가져온다.
			- POST: 서버가 처리해야할 데이터를 보낸다.
			- PUT: 서버에 요청 메세지의 본문을 저장한다.
			- TRACE: 메세지가 프록시를 거쳐 서버에 도달하는 과정을 추적한다.
			- OPTIONS: 서버가 어떤 메서드를 수행할 수 있는지 확인한다.
			- DELETE: 서버에서 문서를 제거한다.
		- 상태코드
			- 메서드가 서버에게 무엇을 해야하는지 말해주는 것처럼, 상태코드는 클라이언트에게 무엇이 일어났는지 말해준다.
			- 100: 정보
			- 200: 성공
			- 300: 리소스가 옮겨졌음을 뜻한다. 리디랙션
			- 400: 클라이언트 에러
			- 500: 서버에러
		- 사유구절
			- 응답 시작줄의 마지막 구성 요소
			- 상태코드의 사람이 이해하기 쉬운 버전
		- 버전 번호
			- 자신이 따르는 프로토콜의 버전이 요청/응답 양쪽에 모두 기술된다.
			- 애플리케이션이 지원하는 가장 높은 HTTP 버전을 가리킨다.
			- HTTP/2.22 > HTTP/2.3 각 숫자를 따로 비교해야한다.
		- 헤더
			- 시작줄 다음에 오는 헤더 - 이름/값 쌍의 목록(Content-length : 19)
			- 요청과 응답 메세지에 추가 정보를 더한다.
			- 헤더 분류 : 여러 헤더 필드를 정의할 수 있고, 애플리케이션은 자신만의 헤더를 만들어낼 수 있다.
				- 일반헤더 : 요청/응답 양쪽에 모두 나타낼수 있음
				- 요청헤더 / 응답 헤더 - 각 요청/응답에 대한 부가정보
				- 엔티티 헤더 : 본문크기과 콘텐츠, 리소스 그 자체를 서술
				- 확장 헤더 : 명세에 정의되지 않은 새로운 헤더
				- Date, Content-length, Content-type, Accept
		- 엔티티 본문
			- HTTP 메세지는 이미지, 비디오, HTML문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 메일 등 여러종류의 데이터를 실어나른다.
			- 이런 메세지가 실어나르는 화물이 엔티티 본문이다.
		- 버전 0.9 메세지 : HTTP 프로토콜의 초기 버전. 단순하며 제약이 있다.


### 3.3 메서드

-   모든 서버가 모든 메소드를 구현하지는 않는다.
-   HTTP는 안전한 메소드의 집합을 정의한다.
    -   GET, HEAD: 서버에 어떤 작용도 없기 때문
    -   안전한 메소드의 목적은 서버에 안전하지 않은 요청이 사용될 때 사용자에게 그 사실을 알려주는 HTTP 애플리케이션을 만들기 위함이다.
    -   GET: 리소스 요청
    -   HEAD: GET처럼 행동하지만 응답으로 헤더만을 돌려준다.
        -   엔티티본문은 반환되지 않는다. 리소스를 가져오지 않고도 리소스의 타입을 알아낼 수 있다.
        -   응답의 상태코드를 통해 리소스 존재 여부를 알 수 있다.
        -   헤더를 확인해 리소스가 변경되었는지 검사할 수 있다.
        -   서버개발자는 반환되는 헤더가 GET요청을 얻는 리소스와 정확히 일치함을 보장해야 한다.
    -   PUT: 서버에 문서를 쓴다. 새문서를 만들거나 수정/교체.
    -   POST: 서버에 입력 데이터를 전송하기 위해 설계되었다. html form
    -   TRACE:
        -   클라이언트는 자신과 목적지 서버 사이에 있는 모든 방화벽, 프록시, 게이트웨이, HTTP애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메세지가 망가졌거나 수정되엇는지, 어떻게 변경되었는지 확인 진단 할 수 있다.
        -   또한, 다른 애플리케이션에 어떤 영향을 미치는지 확인해볼 수 있다.
        -   단, 메소드를 구별하는 메커니즘을 제공하지 않기 때문에 어떻게 TRACE 요청을 처리할 것인지는 중간 애플리케이션이 결정한다.
        -   어떤 엔티티 본문도 보낼 수 없으며, 서버의 응답 엔티티 본문에는 서버가 받은 요청이 그대로 들어있다.
    -   OPTIONS:
        -   웹 서버에 여러 종류의 지원 범위에 대해 물어본다.
        -   어떤 특정 리소스에 대해 어떤 메소드가 지원되는지 물어볼 수 있다.
        -   따라서 리소스에 실제로 접근하지 않고도 어떻게 접근하는게 최선인지 확인할 수 있다.
    -   DELETE: 삭제. HTTP명세는 서버는 클라이언트에 알리지 않고 요청을 무시할 수 있도록 허용한다.
    -   확장 메소드:
        -   HTTP는 필요에 따라 메소드를 확장할 수 있도록 설계되어있다. (ex, LOCK, MKCOL, COPY, MOVE).
        -   자신의 애플리케이션이 이해할 수 없는 확장 메소드를 사용하는 애플리케이션과 마주할 수도 있는데, 이때는 '엄격하게 보내고 관대하게 받아들여라'라는 오랜 규칙에 따라 알려지지 않은 메소드가 담긴 메세지를 다운스트림 서버로 전달하도록 시도하고, end-to-end 행위를 망가뜨리게 될 경우에 501 not implemented 상태코드로 응답하도록 하는 것이 좋다.






### 3-4 상태코드

크게 다섯 가지로 나뉨.

상태코드는 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공

  

#### 100-199: 정보성 상태코드

- HTTP/1.1 에서 도입.

|상태 코드|사유 구절|의미|
|:-:|:-:|:-:|
|100|Continue|요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야 함. <br> 이것을 보낸 후, 서버는 반드시 요청을 받아 응답해야 함.|
|101|Switching Protocols|클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음.|
  

#### 200-299: 성공 상태코드
|상태 코드|사유 구절|의미|
|:-:|:-:|:-:|
|200|OK|요청 정상. 엔터티 본문은 요청된 리소스를 포함하고 있음.|
|201|Created|서버 개체를 생성하라는 요청(ex. PUT)을 위한 것. 서버는 상태 코드를 보내기 전 반드시 객체를 생성해야 함.|
|202|Accepted|요청은 받아들여졌으나 서버는 아직 어떤 동작도 수행하지 않음. 요청 처리 완료에 대한 보장도 없음.|
|204|No Content|응답 메시지는 헤더와 상태줄은 포함하지만, 엔터티 본문은 포함하지 않음.|
|206|Partial Content|부분 혹은 범위 요청이 성공했음.|

  
#### 300-399: 리다이렉션 상태코드

|상태 코드|사유 구절|의미|
|:-:|:-:|:-:|
|300|Multiple Choices|클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청할 경우, 그 리소스의 목록과 함께 반환함. <br> 사용자는 목록에서 원하는 하나를 선택할 수 있음.
|301|Moved Permanently|요청한 URL이 옮겨졌을 때 사용함. <br>응답에 Location 헤더에 현재 리소스의 URL을 포함해야 함.|
|302|Found|301 상태 코드와 같음.<br> 그러나 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 함.|
|303|See Other|클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 말할 때 사용함.<br> 새 URL은 응답 메시지의 Location 헤더에 들어있음.|
|304|Not Modified|리소스가 수정되지 않았음을 의미함. 엔터티 본문을 가져서는 안 됨.|
|305|Use Proxy|리소스가 반드시 프락시를 통해서 접근되어야 함을 나타냄.|

  
#### 400-499: 클라이언트 에러 상태코드

|상태 코드|사유 구절|의미|
|:-:|:-:|:-:|
|400|Bad Request|클라이언트가 잘못된 요청을 보냈다고 말해줌.|
|401|Unauthorized|리소스를 얻기 전에 클라이언트에게 스스로를 인증하라고 요구하는 내용의 응답을 반환함.|
|403|Forbidden|요청이 서버에 의해 거부되었음.|
|404|Not Found|요청한 URL을 찾을 수 없음.|
|405|Method Not Allowed|지원하지 않는 메서드로 요청됨.|
|408|Request Timeout|클라이언트 요청을 완수하는 시간이 오래 걸리는 경우, 이 상태 코드로 응답하고 연결을 끊을 수 있음.|
|409|Conflict|요청이 리소스에 대해 일으킬 수 있는 몇몇 충돌을 지칭하기 위해 사용함.|
|410|Gone|404와 비슷하나, 서버가 한 때 그 리소스를 갖고 있었다는 점이 다름.|
 

#### 500-599: 서버 에러 상태코드
|상태 코드|사유 구절|의미|
|:-:|:-:|:-:|
|500|Internal Server Error|서버가 요청을 처리할 수 없는 에러를 만났을 때 사용함.|
|501|Not Implemented|클라이언트가 서버의 능력을 넘은 요청을 했을 때 사용함.|
|502|Bad Gateway|프락시나 게이트웨이처럼 행동하는 서버가 그 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥뜨렸을 때 사용함.|
|503|Service Unavailable|현재는 서버가 요청을 처리해줄 수 없지만 나중에는 가능함.|
|504|Gateway Timeout|408과 비슷하지만, 다른 서버에 요청을 보내고 응답을 기다리다<br> 타임아웃이 발생한 게이트웨이나 프락시에서 온 응답이라는 점이 다름.|
|505|HTTP Version Not Supported|서버가 지원할 수 없거나 <br>지원하지 않으려고 하는 버전의 프로토콜로 된 요청을 받았을 때 사용함.|



### 3-5 헤더
헤더는 메서드와 함께 클라이언트와 서버가 무엇을 하는지 결정하기 위해 사용
특정 종류의 메시지에만 사용할 수 있는 헤더와 일반 목적으로 사용할 수 있는 헤더, 그리고 응답과 요청 메시지 양쪽 모두에서 정보를 제공하는 헤더가 있다.


#### 일반 헤더
- 메시지에 대한 아주 기본적인 정보를 제공

|헤더|설명|
|:-:|:-:|
|Connection|클라이언트와 서버가 요청/응답 연결에 대한 옵션을 정할 수 있게 해준다.|
|Date|메시지가 언제 만들어졌는지에 대한 날짜와 시간을 제공한다.|
|MIME-Version|발송자가 사용한 MIME의 버전을 알려준다.|
|Trailer chunked transfer|인코딩으로 인코딩된 메시지의 끝 부분에 위치한 헤더들의 목록을 나열한다.|
|transfer-Encoding|수신자에게 안전한 전송을 위해 메시지에 어떤 인코딩이 적용되었는지 말해준다.|
|Upgrade|발송자가 업그레이드하길 원하는 새 버전이나 프로토콜을 말해준다.|
|Via|이 메시지가 어떤 중개자(프락시, 게이트웨이)를 거쳐 왔는지 보여준다.|
|Cache-Control|메시지와 함께 캐시 지시자를 전달하기 위해 사용한다.|
  

#### 요청 헤더
- 요청 메시지에서만 의미를 갖는 헤더
- 요청이 최초 발생한 곳에서 누가 혹은 무엇이 그 요청을 보냈는지에 대한 정보나 클라이언트의 선호나 능력에 대한 정보를 준다

|헤더|설명|
|:-:|:-:|
|Client-IP|클라이언트가 실행된 컴퓨터의 IP를 제공한다.|
|From|클라이언트 사용자의 메일 주소를 제공한다.|
|Host|요청의 대상이 되는 서버의 호스트 명과 포트를 준다.|
|Referer[^1]|현재의 요청 URI가 들어있었던 문서의 URL을 제공한다.|
|UA-Color|클라이언트 기기 디스플레이의 색상 능력에 대한 정보를 제공한다.|
|UA-CPU|클라이언트 CPU의 종류나 제조사를 알려준다.|
|UA-Disp|클라이언트의 디스플레이 능력에 대한 정보를 제공한다.|
|UA-OS|클라이언트 기기에서 동작 중인 운영체제의 이름과 버전을 알려준다.|
|UA-Pixels|클라이언트 기기 디스플레이에 대한 픽셀 정보를 제공한다.|
|User-Agent|요청을 보낸 애플리케이션의 이름을 서버에게 말해준다.|
 

- **Accept 관련 헤더** : 서버에게 자신의 선호와 능력을 알려주는 헤더.

|헤더|설명|
|:-:|:-:|
|Accept|서버에게 서버가 보내도 되는 미디어 종류를 말해준다.|
|Accept-Charset|서버가 보내도 되는 문자집합을 말해준다.|
|Accept-Encoding|서버가 보내도 되는 인코딩을 말해준다.|
|Accept-Language|서버가 보내도 되는 언어를 말해준다.|
|TE|서버가 보내도 되는 확장 전송 코딩(compress, gzip 등)을 말해준다.|
  

- **조건부 요청 헤더** : 특정 조건에 부합할 때만 서버에 요청을 보내는 헤더.

|헤더|설명|
|:-:|:-:|
|Expect|클라이언트가 요청에 필요한 서버의 행동을 열거할 수 있게 해준다. <br>이를 만족하지 않으면 417(Expectation Failed) 상태 응답한다. |
|If-Match|문서의 엔터티 태그가 주어진 엔터티 태그와 일치하는 경우에만 문서를 가져온다.|
|If-Modified-Since|주어진 날짜 이후에 리소스가 변경되지 않았다면 요청을 제한한다.|
|If-None-Match|문서의 엔터티 태그가 주어진 엔터티 태그와 일치하지 않은 경우에만 문서를 가져온다.|
|If-Range|문서의 특정 범위에 대한 요청을 할 수 있게 해준다.|
|If-Unmodified-Since|주어진 날짜 이후에 리소스가 변경되었다면 요청을 제한한다.|
|Range|서버가 범위 요청을 지원한다면, 리소스에 대한 특정 범위를 요청한다. <br> 만약 'bytes=100-200'이라면 리소스 크기가 100에서 20 사이의 바이트일 때만 응답을 보낸다.|

  
- **요청 보안 헤더** : 트랜잭션을 보다 안전하게 만들기 위한 헤더.

|헤더|설명|
|:-:|:-:|
|Authorization|클라이언트가 서버에게 제공하는 인증 그 자체에 대한 정보를 담고 있다.|
|Cookie|클라이언트가 서버에 토큰을 전달할 때 사용한다.|
|Cookie2|클라이언트가 지원하는 쿠키의 버전을 알려준다.|
  
- **프락시 요청 헤더** : 프락시 관련 헤더

|헤더|설명|
|:-:|:-:|
|Max-Forwards|요청이 원 서버로 향하는 과정에서 다른 프락시나 게이트웨이로 전달될 수 있는 최대 횟수. <br>RACE 메소드와 관련|
|Proxy-Authorization|Authorization과 같으나 프락시에서 인증을 할 때 쓰인다.|
|Proxy-Connection|Connection과 같으나 프락시에서 연결을 맺을 때 쓰인다.|
 

#### 응답 헤더
- 클라이언트가 응답을 더 잘 다루고 추후 더 나은 요청을 할 수 있게 도와줌
 
|헤더|설명|
|:-:|:-:|
|Age|응답이 얼마나 오래되었는지 말해준다.|
|Public|서버가 특정 리소스에 대해 지원하는 요청 메서드의 목록을 말해준다.|
|Retry-After|현재 리소스가 사용 불가능한 상태일 때, 언제 가능해지는 날짜 혹은 시각을 말해준다.|
|Server|서버 애플리케이션의 이름과 버전을 말해준다.|
|Title|HTML 문서에서 주어진 것과 같은 제목|
|Warning|사유 구절에 있는 것보다 더 자세한 경고 메시지|
  
- **협상 헤더** : 서버가 협상 가능한 리소스에 대한 정보를 운반

|헤더|설명|
|:-:|:-:|
|Accept-Ranges|서버가 자원에 대해 받아들일 수 있는 범위의 형태|
|Vary|서버가 확인해보아야 하기 때문에 응답에 영향을 줄 수 있는 헤더들의 목록|
  
- **응답 보안 헤더** : 기본적인 인증요구 헤더

|헤더|설명|
|:-:|:-:|
|Proxy-Authenticate|프락시에서 클라이언트로 보낸 인증요구의 목록|
|Set-Cookie|서버가 클라이언트를 인증할 수 있도록 클라이언트 측에 토큰을 설정하기 위해 사용한다.|
|WWW-Authenticate|서버에서 클라이언트로 보낸 인증요구의 목록|
  
#### 엔터티 헤더
- 엔터티와 그것의 내용물에 대한 - 개체의 타입, 메서드 등 - 광범위한 정보 제공

|헤더|설명|
|:-:|:-:|
|Allow|이 엔터티에 대해 수행될 수 있는 요청 메서드들을 나열한다.|
|Location|클라이언트에게 엔터티가 실제로 어디에 위치하고 있는지 알려준다. 새로운 URL 주소를 알려줄 때 사용한다.|
  
- **콘텐츠 헤더** : 엔터티의 콘텐츠에 대한 구체적인 정보를 제공

|헤더|설명|
|:-:|:-:|
|Content-Base|본문에서 사용된 상대 URL을 계산하기 위한 Base URL|
|Content-Encoding|본문에 적용된 인코딩|
|Content-Language|본문을 이해하는데 가장 적절한 자연어|
|Content-Length|본문의 길이 또는 크기|
|Content-Location|리소스의 실제 위치|
|Content-MD5|본문의 MD5 체크섬|
|Content-Range|전체 리소스에서 이 엔터티가 해당하는 범위를 바이트 단위로 표현|
|Content-Type|이 본문이 어떤 종류의 객체인지 말해준다.|

  

- **엔터티 캐싱 헤더** : 언제 어떻게 캐시가 되어야 하는지에 대한 지시자를 제공

|헤더|설명|
|:-:|:-:|
|ETag|이 엔터티에 대한 엔터티 태그|
|Expires|이 엔터티가 더이상 유효하지 않아 원본을 다시 받아와야 하는 일시|
|Last-Modified|가장 최근 이 엔터티가 변경된 일시|


#### 확장 헤더
: 애플리케이션 개발자들에 의해 만들어졌지만 아직 승인된 HTTP 명세에는 추가되지 않은 비표준 헤더.
