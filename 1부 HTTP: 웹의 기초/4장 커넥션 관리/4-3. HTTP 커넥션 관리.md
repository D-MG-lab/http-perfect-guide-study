- 앞의 두 절은 TCP 커넥션과 그로 인한 성능상의 영향을 다루었음
- 이번 절은 커넥션을 생성하고 최적화하는 HTTP 기술을 설명할 것

### 3.1 흔히 잘못 이해하는 Connection 헤더

- HTTP는 클라이언트와 서버 사이에 프락시 서버, 캐시 서버 등과 같은 중개 서버가 놓이는 것을 허락함
- HTTP 메시지는 중개 서버들을 하나하나 거치면서 전달됨
- 어떤 경우에는 2개의 인접한 HTTP 애플리케이션이 현재 맺고 있는 커넥션에만 적용될 옵션을 지정해야 할 때가 있음
- HTTP **Connection** 헤더 필드는 커넥션 토큰을 `,`로 구분하여 가지고 있음
  - 해당 값들은 다른 커넥션에 전달되지 않음
  - 예를 들어, 메시지를 보낸 다음 끊어져야 할 커넥션은 `Connection: close`라고 명시할 수 있음
- Connection 헤더에는 3종류의 토큰이 전달될 수 있음
  - HTTP 헤더 필드 명은, 해당 커넥션에 대한 헤더들을 나열
  - 임시 토큰 값은, 커넥션에 대한 비표준 옵션을 의미
  - close 값은, 커넥션 작업이 완료되면 종료되어야 함을 의미
- 커넥션 토큰이 HTTP 헤더 필드 명을 가지고 있으면,<br>해당 필드들은 현재 커넥션만을 위한 정보이므로 다음 커넥션에 전달하면 안됨
- Connection 헤더에 있는 모든 헤더 필드는 메시지를 다른 곳으로 전달하는 시점에 삭제되어야 함
- Connection 헤더에는 **hop-by-hop** 헤더 명을 기술하는데, 이를 '헤더 보호하기'라고 부름

※ hop-by-hop: hop은 각 서버를 의미하며 hop-by-hop은 두 서버만 영향을 미치고 다른 서버에는 영향을 미치지 않음을 뜻함

![커넥션 헤더](https://user-images.githubusercontent.com/75058239/197367890-80daaf35-0d85-4281-b6ca-ada949b01429.png)

- HTTP 애플리케이션은 Connection 헤더와 함께 메시지를 받았을 때,<br>송신자에게서 온 요청에 기술되어 있는 모든 옵션을 적용함
  - 그리고 다음 hop에게 메시지를 전달하기 전에 Connection 헤더 및 그 안의 모든 헤더들을 삭제함
- Connection 헤더에 기술되지 않은 hop별 헤더도 있음
  - Proxy-Authenticate, Proxy-Connection, Transfer-Encoding, Upgrade 등

### 3.2 순차적인 트랜잭션 처리에 의한 지연

- 커넥션 관리가 제대로 이루어지지 않으면 TCP 성능이 매우 안 좋아질 수 있음
  - 예를 들어 4개의 트랜잭션이 있을 때 각 트랜잭션이 새로운 커넥션을 필요로 한다면,<br>커넥션을 맺을 때 발생하는 지연과 함께 느린 시작 지연이 발생할 것

<img width="750" alt="순차 커넥션" src="https://user-images.githubusercontent.com/75058239/197367949-da963d19-d883-4583-a99a-d869dfa651d8.png">

- 단점
  - 사용자들은 웹페이지에서 이미지가 순차적으로 로드되는 것보다, 여러 이미지가 동시에 로드되는 방식이 더 빠르다고 느낄 것
  - 특정 브라우저의 경우 객체를 화면에 배치하기 전 객체의 크기를 알아야 하는데,<br>모든 객체를 다 내려받기 전에 알 방법이 없고, 따라서 텅 빈 화면을 보여주게 됨
- 그러므로 등장한, HTTP 커넥션의 성능을 향상시킬 수 있는 채신 기술들
  - **parallel 커넥션** : 여러 TCP 커넥션을 활용한 동시 요청
  - **persistent 커넥션** : 커넥션 맺음 및 끊기에서 발생하는 지연을 제거하기 위한 TCP 커넥션 재활용
  - **pipelined 커넥션** : 공유 TCP 커넥션을 통한 병렬 요청
  - **multiplexed 커넥션** : 요청과 응답들에 대한 중재 (실험적인 기술)
