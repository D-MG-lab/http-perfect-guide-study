## 4장 커넥션 관리

### 4.1 TCP 커넥션

전 세계 모든 HTTP 통신은 세계 어디서든 일단 커넥션이 맺어지면 클라이언트 애플리케이션과 서버 애플리케이션 간 손상되지 않은 메시지를 전달할 수 있다.

#### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

TCP는 충돌 없이 순서에 맞게 HTTP데이터를 전달한다.

- 클라이언트가 서버로 ‘GET/index.html …’를 요청한다면 문자 순서 그대로 전달된다.

#### 4.1.2 TCP 스트임은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다

- HTTP와 HTTPS 네트워크 프로토콜 스택
- TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고, 세그먼트를 IP 패킷이라 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달한다. TCP/IP 소프트웨어에 의해 처리되며, 과정은 HTTP프로그래머에게 보이지 않는다.
- 각 TCP 세그먼트는 하나의 IP주소에서 다른 IP주소로 IP패킷에 담겨 전달된다.
- IP 패킷 헤더(보통 20바이트)
- TCP 세그먼트 헤더(보통 20바이트)
- TCP 데이터 조각(0 혹은 그 이상의 바이트)
- IP헤더는 발신지와 목적지 IP주소, 크기, 기타 플래그를 가진다.
- TCP 세그먼트 헤더는 TCP 포트번호, TCP 제어 플래그, 데이터 순서와 무결성 검사를 위한 숫자 값을 포함한다.

#### 4.1.3 TCP 커넥션 유지하기

- 컴퓨터는 항상 TCP 커넥션을 여러 개 가진다. 네 가지 값으로 식별한다.
- <발신지 IP주소, 발신지 포트, 수신지 IP 주소, 수신지 포트>
- 커넥션들이 같은 목적지 포트 번호를 가리키고 있어도 네가지 커넥션 구성요소를 모두 똑같이 가리키고 있는 커넥션은 있을 수 없다.

#### 4.1.4 TCP 소켓 프로그래밍

- 소켓 API를 사용하면 TCP 엔드포인트 데이터 구조를 생성하고, 원격 서버의 TCP 엔드포인트에 해당 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.
- TCP API는 기본 네트워크 프로토콜의 핸드셰이킹, TCP 데이터 스트림과 IP 패킷 간의 분할 및 재조립에 대한 모든 세부사항을 외부로부터 숨긴다.


### 4.2 TCP의 성능에 대한 고려

#### 4.2.1 HTTP 트랜잭션 지연

- 트랜잭션을 처리하는 시간은 TPC 커넥션을 설정하고, 요청을 전송하고, 응답 메시지를 보내는 것에 비해 상당히 짧다.
- 대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생한다.
- HTTP 트랜잭션을 지연시키는 원인은 여러 가지가 있다.
1. URI에 기술된 호스트에 클라이언트가 최근에 방문한 적이 없으면 URI에 있는 호스트 명을 IP주소로 변환하는데 수십 초의 시간이 걸린다.
2. 커넥션 설정 시간은 새로운 TCP 커넥션에서 항상 발생하는데, 보통 1~2초가 소요되지만 대량의 HTTP 트랜잭션이 만들어지면 소요시간이 크게 증가한다.
3. 커넥션이 맺어진 후 클라이언트의 HTTP 요청이 인터넷을 통해 전달되고 서버에서 처리하는 데에 시간이 소요된다.
4. 웹 서버가 HTTP 응답을 보내는 데에 시간이 소요된다.

#### 4.2.3 TCP 커넥션 핸드셰이크 지연

- TCP 커넥션 핸드셰이크 지연
![TCP 커넥션 핸드셰이크 지연](https://feel5ny.github.io/images/2019/24/6.jpg)
    
1. 클라이언트는 새로운 TCP 커넥션 생성을 위해 작은 TCP 패킷(SYN플래그, 40~60바이트)을 서버에 보낸다.
2. 서버가 커넥션을 받으면 커넥션 매개변수를 산출한 후, 커넥션 요청이 받아들여졌음을 의미하는 ‘SYN’과 ‘ACK’플래그가 포함한 TCP 패킷을 클라이언트에 보낸다.
3. 클라이언트는 커넥션이 맺어진 후 서버에 다시 확인 응답 패킷과 데이터를 보낸다.

- 크기가 작은 HTTP 트랜잭션은 절반 이상의 시간을 TCP 구성에 쓴다.

#### 4.2.4 확인응답 지연

- 각 TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가지는데, 만약 송신자가 특정 시간 안에 확인 응답 메시지를 받지 못하면 오류로 팒단하여 데이터를 재전송한다.
- 확인응답은 크기가 작아서 TCP는 송출되는 데이터 패킷에 확인응답을 ‘편승(piggyback)’시킨다. 이는 네트워크를 효율적으로 사용하기 위함인데, 많은 TCP 스택은 ‘확인응답 지연’ 알고리즘을 구현한다.
- 확인응답 지연은 송출할 확인응답을 특정 시간(0.1~0.2초) 버퍼에 저장 후 송출 데이터 패킷을 찾는다. 찾지 못하면 별도 패킷을 만들어 전송된다.
- 요청과 응답의 두 가지 형식으로만 이루어지는 HTTP 방식은 지연이 자주 발생하는데, 원인이 되는 지연 관련 기능을 수정하거나 비활성화 할 수 있다.

#### 4.2.5 TCP 느린 시작(slow start)

- 느린시작과 혼잡제어
![느린시작과 혼잡제어](https://velog.velcdn.com/images%2Fmu1616%2Fpost%2F71182a17-fef8-4d94-938b-2a19a628b7f1%2Fimage.png)
    
- 인터넷의 급작스러운 부하와 혼잡을 방지하기 위하여 TCP가 한번에 전송할 수 있는 패킷의 수를 제한한다.
- HTTP 트랜잭션에서 전송할 데이터의 양이 많으면 모든 패킷을 한 번에 전송할 수 없기 때문에, 한 개의 패킷만 우선 전송하고 확인응답을 받은 후 2개의 패킷을 보낸다. 이런식으로 다시 응답을 받으면 총 4개의 패킷을 보낼 수 있다.
- 혼잡제어 기능 때문에 새로운 커넥션은 이미 데이터를 주고받은 ‘튜닝’된 커넥션보다 느리다.

#### 4.2.6 네이글(Nagle) 알고리즘과 TCP_NODELAY

- 네이글 알고리즘은 네트워크 효율을 위해 많은 양의 TCP데이터를  한 개의 덩어리로 합친다. 이 때 세그먼트가 최대 크기(수백 ~ 최대 1500바이트)가 되지 않으면 전송을 하지 않는다. 다른 모든 패킷이 확인응답을 받은 경우에는 최대크기가 되지 않아도 전송한다.
- HTTP 성능과 관련하여 네이글 알고리즘은 여러 문제를 발생시킨다.
1. 크기가 작은 HTTP 메시지는 패킷을 채우지 못해서 추가적인 데이터를 기다리며 지연된다.
2. 확인응답 지연과 함께 쓰일 경우 응답이 도착할 때까지 데이터 전송을 멈추고 확인응답 지연 알고리즘은 확인응답을 100~200밀리초 지연시킨다.

#### 4.2.7 TIME_WAIT의 누적과 포트 고갈

- 성능 측정 시에 TIME_WAIT 포트 고갈은 심각한 성능 저하를 발생시킨다.
- TCP 커넥션의 엔드포인트에서 TCP 커넥션을 끊으면, 엔드포인트에서 커넥션 IP주소와 포트번호를 메모리에 기록한다. 이는 같은 주소와 포트번호를 사용하는 새로운 TCP 커넥션이 2MSL의 시간동안 생성되지 않도록 하기 위함인데, 성능 측정 시에 서버는 클라이언트가 접속할 수 있는 IP주소의 개수를 제한하고 서버에 접속하여 부하를 발생기키는 컴퓨터 수는 적기 때문에 가능한 연결 조합이 제한된다.
- 부하를 생성하는 장비를 많이 사용하거나 여러 가상 IP주소를 사용할 수 있지만, 커넥션을 너무 많이 맺거나 대기 상태의 제어 블록이 너무 많아지는 상황은 주의해야 한다.


### 4.3 HTTP 커넥션 관리
- 앞의 두 절은 TCP 커넥션과 그로 인한 성능상의 영향을 다루었음
- 이번 절은 커넥션을 생성하고 최적화하는 HTTP 기술을 설명할 것

#### 4.3.1 흔히 잘못 이해하는 Connection 헤더

- HTTP는 클라이언트와 서버 사이에 프락시 서버, 캐시 서버 등과 같은 중개 서버가 놓이는 것을 허락함
- HTTP 메시지는 중개 서버들을 하나하나 거치면서 전달됨
- 어떤 경우에는 2개의 인접한 HTTP 애플리케이션이 현재 맺고 있는 커넥션에만 적용될 옵션을 지정해야 할 때가 있음
- HTTP **Connection** 헤더 필드는 커넥션 토큰을 `,`로 구분하여 가지고 있음
  - 해당 값들은 다른 커넥션에 전달되지 않음
  - 예를 들어, 메시지를 보낸 다음 끊어져야 할 커넥션은 `Connection: close`라고 명시할 수 있음
- Connection 헤더에는 3종류의 토큰이 전달될 수 있음
  - HTTP 헤더 필드 명은, 해당 커넥션에 대한 헤더들을 나열
  - 임시 토큰 값은, 커넥션에 대한 비표준 옵션을 의미
  - close 값은, 커넥션 작업이 완료되면 종료되어야 함을 의미
- 커넥션 토큰이 HTTP 헤더 필드 명을 가지고 있으면,<br>해당 필드들은 현재 커넥션만을 위한 정보이므로 다음 커넥션에 전달하면 안됨
- Connection 헤더에 있는 모든 헤더 필드는 메시지를 다른 곳으로 전달하는 시점에 삭제되어야 함
- Connection 헤더에는 **hop-by-hop** 헤더 명을 기술하는데, 이를 '헤더 보호하기'라고 부름

※ hop-by-hop: hop은 각 서버를 의미하며 hop-by-hop은 두 서버만 영향을 미치고 다른 서버에는 영향을 미치지 않음을 뜻함

![커넥션 헤더](https://user-images.githubusercontent.com/75058239/197367890-80daaf35-0d85-4281-b6ca-ada949b01429.png)

- HTTP 애플리케이션은 Connection 헤더와 함께 메시지를 받았을 때,<br>송신자에게서 온 요청에 기술되어 있는 모든 옵션을 적용함
  - 그리고 다음 hop에게 메시지를 전달하기 전에 Connection 헤더 및 그 안의 모든 헤더들을 삭제함
- Connection 헤더에 기술되지 않은 hop별 헤더도 있음
  - Proxy-Authenticate, Proxy-Connection, Transfer-Encoding, Upgrade 등

#### 4.3.2 순차적인 트랜잭션 처리에 의한 지연

- 커넥션 관리가 제대로 이루어지지 않으면 TCP 성능이 매우 안 좋아질 수 있음
  - 예를 들어 4개의 트랜잭션이 있을 때 각 트랜잭션이 새로운 커넥션을 필요로 한다면,<br>커넥션을 맺을 때 발생하는 지연과 함께 느린 시작 지연이 발생할 것

<img width="750" alt="순차 커넥션" src="https://user-images.githubusercontent.com/75058239/197367949-da963d19-d883-4583-a99a-d869dfa651d8.png">

- 단점
  - 사용자들은 웹페이지에서 이미지가 순차적으로 로드되는 것보다, 여러 이미지가 동시에 로드되는 방식이 더 빠르다고 느낄 것
  - 특정 브라우저의 경우 객체를 화면에 배치하기 전 객체의 크기를 알아야 하는데,<br>모든 객체를 다 내려받기 전에 알 방법이 없고, 따라서 텅 빈 화면을 보여주게 됨
- 그러므로 등장한, HTTP 커넥션의 성능을 향상시킬 수 있는 채신 기술들
  - **parallel 커넥션** : 여러 TCP 커넥션을 활용한 동시 요청
  - **persistent 커넥션** : 커넥션 맺음 및 끊기에서 발생하는 지연을 제거하기 위한 TCP 커넥션 재활용
  - **pipelined 커넥션** : 공유 TCP 커넥션을 통한 병렬 요청
  - **multiplexed 커넥션** : 요청과 응답들에 대한 중재 (실험적인 기술)


### 4.4 병렬 커넥션

<img width="750" alt="병렬 커넥션" src="https://user-images.githubusercontent.com/75058239/197368641-9c8e8826-303e-44c5-9327-ed6d799e39a0.png">

#### 4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다

- 커넥션 대역폭 제한 및 커넥션이 놀고 있는 시간을 잘 활용하면, 여러 객체가 있는 웹페이지를 빠르게 내려받을 수 있음
- 각 커넥션의 지연 시간을 겹치게 하면 총 지연 시간을 줄일 수 있고,<br>대역폭에 여유가 있다면 나머지 객체를 내려받는 데에 활용할 수 있음

<img width="750" alt="병렬 트랜잭션" src="https://user-images.githubusercontent.com/75058239/197368653-436fb7a0-e3a7-4e26-bab4-5847fcc1d0af.png">

#### 4.2 병렬 커넥션이 항상 더 빠르지는 않다

- 클라이언트의 네트워크 대역폭이 좁은 경우에는 대부분의 시간을 데이터 전송에만 쓰게 될 것
- 여러 개의 객체를 병렬로 내려받는데 대역폭이 한정되어 있다면, 각 객체 전송이 느리기 때문에 성능상의 이점이 거의 없어짐
- 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제를 발생시킴
  - 복잡한 웹페이지는 수백 개의 객체를 포함하는데, 서버에서 수백 개의 커넥션을 허용하는 경우는 드묾
  - 100명의 사용자가 100개의 커넥션을 맺고 있다면 서버는 총 10,000개의 커넥션을 떠안게 되는 셈
- 브라우저는 실제로 병렬 커넥션을 사용하긴 하지만 적은 수(6~8개)의 병렬 커넥션만을 허용함
- 서버는 특정 클라이언트로부터 과도한 수의 커넥션이 맺어졌을 경우, 임의로 끊어버릴 수도 있음

#### 4.3 병렬 커넥션은 더 빠르게 '느껴질 수' 있다

- 병렬 커넥션이 실제로 페이지를 더 빨리 내려받진 않고 있지만,<br>화면이 여러 개의 객체를 동시에 보이면서 내려받고 있는 상황을 보여주면 사용자는 빠르다고 느낄 수 있음
- 사용자는 페이지의 총 다운로드 시간이 더 걸린다 해도<br>화면 전체에서 여러 작업이 일어나는 것을 눈으로 확인할 수 있으면 더 빠르다고 여김
  - 처음에는 저해상도를 보여주었다가 점차 해상도를 높여가는 이미지를 활용하면 그 효과를 극대화할 수 있음
