## 10장 HTTP/2.0

- 현재 책의 내용은 HTTP/2.0의 8번째 초안(2014.05.15)이며 관련한 이후 초안은 17번째 초안(2015.08.15) 까지 있음

## 1. HTTP/2.0의 등장 배경

- HTTP/1.1의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화되었기 때문에 성능에서는 아쉬움이 있다.
- 응답을 받아야 다음 요청을 보낼 수 있었는데 이로인한 회전 지연(latency)이 문제가 되었다.
- 2009년 구글이 회전 지연을 줄이기 위하여 SPDY(스피디) 프로토콜을 개발했고, 2012년 HTTP 작업그룹이 SPDY 기반으로 HTTP/2.0 프로토콜을 설계하기로 하였다.

## 2. 개요

- 프레임들에 담긴 요청과 응답은 스트림을 통해 보내지는데, 하나의 커넥션에 여러 스트림이 동시에 만들어질 수 있고 여러 요청과 응답도 가능하다. 또한, 우선순위 부여도 가능하다.
- HTTP/2.0에는 클라이언트의 요청이 없더라도 서버 푸시를 통해 능동적으로 클라이언트가 필요할 리소스를 전송한다.
- HTTP/1.1에서의 **Content-Length** 헤더 이름을 HTTP/2.0에서는 **:content-length**로 표현하는 등 문법이 변경 되었다.

## 3. HTTP/1.1과의 차이점

### 3.1 프레임

- HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송되고, 프레임은 8바이트 크기의 헤더에서 시작해 최대 16383바이트 크기의 페이로드가 온다.
  [프레임의 구조]()

### 3.2 스트림과 멀티플렉싱

- HTTP/1.1에서 하나의 TCP 커넥션을 통해 요청을 보냈을 때, 그에 대한 응답이 도착해야 같은 TCP 커넥션으로 요청을 보낼 수 있다. 따라서 여러 개의 TCP 커넥션을 만들어 동시에 요청을 보내는 방법을 사용한다. 그럼에도 무한정으로 TCP 커넥션을 만들 수 없기 때문에 파이프라인 커넥션을 이용하였으나 널리 구현되지 않았다.
- HTTP/2.0에서는 하나의 커넥션에 여러 개의 스트림을 동시에 열어 여러 개의 요청이 동시에 보내질 수 있기 때문에 문제가 쉽게 해결되었다.
- 스트림에서는 우선 순위기능을 통해 보다 중요한 리소스를 요청하는 스트림에 우선 순위를 부여할 수도 있다.
- 모든 스트림은 31비트의 무부호 정수로 된 고유한 식별자를 갖고, 스트림이 클라이언트에 의해 초기화 되면 식별자는 반드시 홀수고 서버라면 짝수다. 새로 만들어지는 스트림의 식별자는 이전에 만들어진 식별자 보다 크다.
- 서버와 클라이언트는 스트림을 상대방과 협상 없이 일방적으로 만드는데, 스트림을 만들 때 TCP 패킷을 주고받느라 시간을 낭비하지 않을 수 있다.
- 한번 사용한 스트림 식별자는 다시 사용할 수 없고, 스트림에 할당할 수 있는 식별자가 고갈되면 커넥션을 다시 맺는다.

### 3.3 헤더 압축

- HTTP/1.1에서는 헤더가 압축없이 그대로 전송되었는데 과거 웹페이지 방문시 요청이 많지 않았기 때문이다. 그러나 최근에는 웹페이지 방문에 요청이 훨씬 많아졌고 헤더의 크기가 회전 지연과 대역폭 양쪽에 영향을 끼치게 되었다.
- HTTP/2.0에서는 HTTP 메시지의 헤더를 압축한 후 '헤더 블록 조각'들로 쪼개져서 전송된다. 받는 쪽에서는 조각을 이은 후 압축을 풀어 헤더를 복원한다.
- 헤더를 압축하고 해제할 때 올바른 '압축 콘텍스트'를 사용하는데 수신한 헤더의 압축을 풀면 영향을 받아 바뀐다. 헤더를 받은 수신측은 반드시 무조건 압축 해제를 해야하는데, 그럴 수 없는 경우에는 COMPRESSION_ERROR를 보내면서 커넥션을 끊어야 한다.

### 3.4 서버 푸시

- HTTP/2.0은 서버가 하나의 요청에 대한 응답으로 여러 개의 리소스를 보낼 수 있도록 하는데, 이는 클라이언트가 어떤 리소스를 요구 할 것인지 미리 알 수 있는 상황에서 유용하다. 이는 클라이언트가 필요한 리소스를 다시 요청하면서 발생하는 트래픽과 회전 지연을 줄여준다.
- 리소스를 푸시하는 서버는 클라이언트에게 리소스를 푸시할 거임을 PUSH_PROMISE 프레임을 보내서 미리 알려주는데, 클라이언트는 해당 프레임을 받으며 '예약됨' 상태가 된다. 이때 클라이언트는 RST_STREAM 프레임을 보내서 푸시를 거절할 수 있다.
- PUSH_PROMISE를 먼저 보내는 이유는 서버가 푸시하려는 리소스를 클라이언트가 별도로 요청하는 상황을 피하기 위함이다.

### 4. 알려진 보안 이슈

### 4.1 중개자 캡슐화 공격

- HTTP/2.0 메시지를 중간의 프락시가 HTTP/1.1메시지로 변환할 때 메시지의 의미가 변질될 가능성이 있는데, HTTP/2.0 요청이나 응답이 위조된 HTTP/1.1 메시지로 번역되는 것을 유발할 수 있다.
- HTTP/1.1 메시지를 HTTP/2.0 메시지로 번역하는 과정에서는 문제가 발생하지 않는다.

### 4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

- HTTP/2.0은 사용자가 요청을 보낼 때 지연 회전을 줄이기 위해 클라이언트와 서버의 커넥션을 오래 유지할 수 있는데, 이는 개인 정보 유출에 악용될 수 있다.
- 사용자가 해당 브라우저로 이전에 무엇을 했는지 알아낼 가능성이 있다.
- 짧게 유지되는 커넥션에서는 위험이 적다.
