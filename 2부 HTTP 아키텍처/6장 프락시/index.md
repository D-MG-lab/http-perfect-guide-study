## 6장 프락시

## 4. 클라이언트 프락시 설정

- 모든 현대적 브라우저들은 프락시 사용에 대해 설정할 수 있음

**수동 설정**

- 프락시를 사용하겠다는 명시적 설정

**브라우저 기본 설정**

- 브라우저 벤더나 배포자는 브라우저를 소비자에게 전달하기 전에 미리 프락시를 설정해 놓을 수 있음

**Proxy auto-configuration (PAC)**

- JavaScript PAC 파일에 대한 URI를 제공할 수 있음
- JS 파일을 통해 클라이언트가 언제 프락시를 쓰는지, 어떤 프락시 서버를 쓰는지 판단하고 실행함

**WPAD(Web Proxy Autodiscovery Protocol) 프락시 발견**

- 대부분의 브라우저들은 자동설정 파일을 다운받을 수 있는 '설정 서버'를 자동으로 찾아주는 WPAD를 제공함

### 4.1 클라이언트 프락시 설정: 수동

- 많은 웹 클라이언트가 프락시를 수동으로 설정할 수 있도록 하고 있음
- Chrome: 설정 > '시스템' 검색 > '컴퓨터 프록시 설정 열기' 클릭
- 브라우저마다 수동 설정에 대한 다른 방법들을 갖고 있지만 아이디어 자체는 같음
- 몇몇 ISP는 미리 설정된 브라우저나 웹 트래픽을 프락시 서버로 리다이렉트하는 맞춤형 운영체제를 구입함

### 4.2 클라이언트 프락시 설정: PAC 파일

- 수동 프락시 설정은 단순하고 유연하지 못함
  - 모든 컨텐츠를 위해 단 하나의 프락시 서버만을 지정할 수 있음
  - 장애 시의 대체 작동에 대한 지원도 없음
  - 설정된 브라우저가 많다면, 모든 브라우저를 원하는 대로 설정을 변경해야 함
- PAC 파일은 보다 동적인 해결책을 제시해줌
  - 상황에 맞게 계산해주는 작은 JS 프로그램이기 때문
  - 문서에 접근할 때마다 JS 함수가 적절한 프락시 서버를 선택함
- PAC 파일 사용을 위해서는 JS PAC 파일의 URI를 브라우저에 설정해야 함
- 설정 이후 브라우저는 URI로부터 PAC 파일을 가져와서 매 접근마다 적절한 프락시 서버를 계산하기 위해 JS 로직을 활용하게 될 것
- PAC 파일은 일반적으로 `.pac` 확장자를 가지며 MIME 타입은 `application/x-ns-proxy-autoconfig`
- 각 PAC 파일은 반드시 URI 접근시 적절한 프락시 서버를 계산해주는 `FindProxyForUrl(url, host)` 함수를 정의해야 함

※ `FindProxyForUrl(url, host)` 함수의 반환값

|   함수 반환값   | 설명                              |
| :-------------: | :-------------------------------- |
|     DIRECT      | 프락시 연결 없이 직접 이루어질 것 |
| PROXY host:port | 지정한 프락시를 사용할 것         |
| SOCKS host:port | 지정한 SOCKS 서버를 사용할 것     |

※ HTTP 트랜잭션과 FRP 트랜잭션에 대해 각각의 프락시를 설정하고, 다른 종류의 트랜잭션은 직접 연결하도록 지시하는 예시

```js
function FindProxyForURL(url, host) {
  if (url.substring(0, 5) == "http:") {
    return "PROXY http-proxy.mydomain.com:8080";
  } else if (url.substring(0, 4) == "ftp:") {
    return "PROXY ftp-proxy.mydomain.com:8080";
  } else {
    return "DIRECT";
  }
}
```

### 4.3 클라이언트 프락시 설정: WPAD

- 웹 프락시 자동발견 프로토콜은 여러 발견 메커니즘들의 상승 전략을 활용해서 브라우저에게 알맞는 PAC 파일을 자동으로 찾아주는 알고리듬
- WPAD 프로토콜이 구현된 클라이언트가 하게 될 일들
  - PAC URI를 찾기 위해 WPAD 사용
  - 주어진 URI에서 PAC 파일을 가져옴
  - 프락시 서버를 알아내기 위해 PAC 파일 실행
  - 알아낸 프락시 서버를 이용해서 요청 처리
- WPAD는 올바른 PAC 파일을 찾기 위해 일련의 리소스 발견 기법을 사용함
  - 여러 기법을 가지고 성공할 때까지 하나씩 기법을 시도해봄
- WPAD 명세에 기록된 기법의 순서
  - DHCP (동적 호스트 발견 규약)
  - SLP (서비스 위치 규약)
  - DNS 잘 알려진 호스트 명
  - DNS SRV 레코드
  - DNS TXT 레코드 안의 서비스 URI

<br>

## 5. 프락시 요청의 미묘한 특징들

- 프락시 서버 요청의 미묘하고도 오해하기 쉬운 측면들
  - 프락시 요청의 URI와 서버 요청의 URI의 차이
  - 인터셉트 프락시와 리버스 프락시가 서버 호스트 정보를 어떻게 감추는지
  - URI 수정 규칙
  - 프락시가 브라우저의 똑똑한 URI 자동완성이나 호스트 명 확장 기능에 어떻게 영향을 줄 수 있는지

### 5.1 프락시 URI는 서버 URI와 다르다

- 웹 서버와 웹 프락시 메시지의 문법은 서로 같지만, 요청의 URI는 다름

※ 클라이언트가 웹 서버로 요청을 보낼 때는 스킴, 호스트, 포트번호가 없는 부분 URI를 가짐

```
GET /index.html HTTP/1.0
User-Agent: SuperBrowser v1.3
```

※ 클라이언트가 프락시로 요청을 보낼 때는 완전한 URI를 가짐

```
GET http://www.marys-antique.com/index.html HTTP/1.0
User-Agent: SuperBrowser v1.3
```

Q. 이러한 차이가 생기는 이유는?

- 기존 HTTP 설계에서, 클라이언트는 서버하고만 직접 대화를 했음
  - 가상 호스팅이 아직 존재하지 않았고, 프락시에 대한 대비도 없었음
- 단일 서버와 직접 대화할 경우에는 서버가 자신의 호스트 명과 포트번호를 알고 있음
  - 따라서 클라이언트는 불필요한 정보 발송을 피하기 위해 **부분 URI**를 보낼 수 있는 것
- 프락시가 떠오르면서, 부분 URI는 문제가 되었음
  - 프락시는 목적지 서버와 커넥션을 맺어야 하기 때문에 서버의 이름을 알 필요가 있었음
  - 또 프락시 기반 게이트웨이는 FTP 리소스 혹은 그 외 스킴과의 연결을 위해 URI의 스킴을 알 필요가 있었음
- 그래서 HTTP/1.0, HTTP/1.1 은 서버들이 완전한 URI를 다룰 것을 요구함
  - 그러나 현실적으로 이미 너무 많은 기존 서버들이 배치되어 있어서, 여전히 많은 서버들이 부분 URI만을 받아들이고 있음
- 그렇기에 우리는 서버로는 부분 URI를, 프락시로는 완전한 URI를 보낼 필요가 있는 것
- 클라이언트가 프락시에 대해 명시적으로 설정해두었을 경우에는 어떻게 요청을 보낼지 스스로 알고 있음
  - 클라이언트가 프락시를 사용하지 않도록 설정했다면, 부분 URI를 보냄
  - 클라이언트가 프락시를 사용하도록 설정했다면, 완전 URI를 보냄

<img width="503" alt="요청 URI의 변경" src="https://user-images.githubusercontent.com/75058239/199850780-b70c7b56-0f4a-4a22-bf39-81433602b788.png">

### 5.2 가상 호스팅에서 일어나는 같은 문제

- 부분 URI를 사용할 때 생기는 문제는 가상으로 호스팅되는 웹 서버에도 발생함
- 가상 호스팅 웹 서버는 여러 웹 사이트가 동일한 물리적 웹 서버를 공유함
  - 따라서 요청 하나가 부분 URI로 오면, 가상 호스팅 웹 서버는 요청이 접근하고자 하는 웹 사이트의 호스트 명을 알 필요가 있음
- 이에 대한 2가지 해결책
  - 명시적인 프락시를 활용해서, 요청 메시지가 완전한 URI를 갖도록 함
  - 호스트와 포트에 대한 정보가 담겨 있는 Host 헤더를 요구

### 5.3 인터셉트 프락시는 부분 URI를 받는다

- 클라이언트는 명시적으로 설정된 프락시에게 완전한 URI를 줄 것
- 하지만 클라이언트는 자신이 프락시와 대화하고 있음을 항상 아는 것이 아님 (몇몇 프락시는 클라이언트에게 보이지 않을 수 있기 때문에)
- 설령 클라이언트가 프락시 사용 설정을 안 해두어도, 트래픽은 여전히 대리 프락시나 인터셉트 프락시를 지날 수도 있음
  - 두 가지 경우 모두, 클라이언트는 자신이 웹 서버와 대화하고 있다고 생각하고 부분 URI를 보내게 될 것
- 두 프락시가 하게 될 일
  - 대리 프락시는 원 서버의 호스트 명과 IP 주소를 이미 가지고 있음
  - 인터셉트 프락시는 트래픽을 가로채서 캐시된 응답을 돌려줌

### 5.4 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있다

- 트래픽이 프락시 서버로 리다이렉트될 수 있는 여러 방법들이 존재하기 때문에,<br>다목적 프락시 서버는 완전 URI와 부분 URI를 모두 지원해야 함

⭐ 프락시가 완전 URI와 부분 URI를 다루는 규칙

- 완전 URI가 주어졌다면 그것을 사용할 것
- 부분 URI가 주어졌고 Host 헤더가 있다면 Host 헤더를 통해 원 서버를 알아낼 것
- 부분 URI가 주어졌는데 Host 헤더도 없다면 다음 방법들을 동원해서 원 서버를 알아내야 함
  - 대리 프락시의 경우에는 프락시에 원 서버의 주소와 포트번호가 설정되어 있을 것
  - 이전에 인터셉트 프락시가 받은 트래픽을 통해서 서버 주소와 포트번호를 사용할 수 있도록 해두었다면 이를 활용할 수 있음
  - 모두 실패했다면 프락시는 충분한 정보를 갖고 있지 못한 것이므로 에러 메시지를 반환해야 함 (보통은 Host 헤더를 지원하는 현대 브라우저 사용을 권장)

### 5.5 전송 중 URI 변경

- 사소한 URI 변경이라도 다운스트림 서버와 상호운용성 문제를 일으킬 수 있으므로 주의해야 함
- 특히 몇몇 프락시는 URI를 다음 hop으로 보내기 전에 표준 형식으로 '정규화'를 하고 있음
- 기본 HTTP포트 ':80'을 명시적으로 붙여주는 등의 무해해 보이는 변형이라 해도 상호운용성 문제를 일으킬 수 있음
- 일반적으로 프락시 서버는 가능한 한 관대해야 하며, 프로토콜 준수를 강요하는 프로토콜 경찰처럼 되어서는 안됨
- 특히 HTTP 명세는 인터셉트 프락시가 절대 경로를 고치는 것을 금지함
  - 유일한 예외는 빈 경로를 `/`로 교체할 때뿐

### 5.6 URI 클라이언트 자동확장과 Hostname Resolution

- 프락시가 없다면 브라우저는 사용자가 타이핑한 URI에 대응하는 IP 주소를 찾아냄
- 호스트를 찾아낼 수 없을 때는 자동화된 호스트 명 '확장'을 시도함
  - `www.` 접두사와 `.com` 접미사를 붙여줌
  - 심지어 URI를 서드파티 사이트로 넘겨서 오타 교정을 시도하는 브라우저들도 있음
  - DNS는 사용자가 호스트 명의 앞부분만 입력하면 자동으로 도메인을 검색하도록 설정되어 있음

### 5.7 프락시 없는 URI Resolution

![URI 분석](https://user-images.githubusercontent.com/75058239/200095916-1445c5aa-b1f2-467e-bddc-57e228e19fe5.png)

- 브라우저는 유효한 호스트 명이 발견될 때까지 다양한 호스트 명의 가능성들을 검색함

### 5.8 명시적인 프락시를 사용할 때의 URI Resolution

![명시적 프락시와 URI 분석](https://user-images.githubusercontent.com/75058239/200095925-39caa362-8c1a-4e67-be0e-bc0000c51d1c.png)

- 명시적인 프락시를 사용한다면 브라우저는 이 편리한 확장 기능들을 사용할 수 없음
  - 브라우저의 URI가 프락시를 그냥 지나쳐버리기 때문
- 이 때문에 몇몇 프락시는 `www.` `.com` 자동확장이나 지역 도메인 접미사 추가 등의 기능을 최대한 흉내 내려고 시도함
  - 그러나 프락시는 광범위하게 사용되고 있기에, 개개인들 모두에게 맞는 도메인 접미사를 알아내는 것은 불가능할 것

### 5.9 인터셉트 프락시를 이용한 URI Resolution

![인터셉트 프락시와 URI 분석](https://user-images.githubusercontent.com/75058239/200095930-46423352-6694-4cd2-bb81-1290c40148ed.png)

- 보이지 않는 인터셉트 프락시를 사용한다면 또 얘기가 달라짐
- 브라우저 입장에서 프락시는 존재하지 않는 것이기 때문에 호스트 명 자동확장을 계속 수행하게 될 것
- 만약 클라이언트가 DNS 서버를 통해 유효한 IP 주소를 찾아냈지만, 실제론 서버가 죽어 있는 경우에 골치가 아파짐
  - 죽은 서버 IP에 대한 첫번째 접속은 우선 원 서버가 아닌 프락시 선에서 종료될 것
  - 그런데 프락시는 진짜 원 서버와 상호작용할 준비가 되었을 때 해당 IP 주소가 죽은 서버를 가리키고 있음을 알게 될 것
  - 프락시는 브라우저와 동등한 수준의 **fault tolerance**를 제공하기 위해서 다른 IP 주소를 찾아내고 시도해야 함
- 명시적인 프락시와 인터셉트 프락시 모두 죽은 서버의 DNS 분석에 대한 fault tolerance를 지원하는 것이 중요한 포인트

### 6.6 메시지 추적
오늘날 웹 요청의 상당수가 프록시를 지나간다. 
- 보안,성능을 위한 프록시 캐시
- 성능 개선, 기능 구현을 위한 ISP의 프록시 캐시
프록시가 점점 더 흔해지면서, 서로 다른 스위치나 라우터를 넘나드는 IP 패킷의 흐름을 추적하는 것 못지 않게 프락시를 넘나드는 메시지의 흐름을 추적하고 문제점을 찾아내는 것도 필요한 일이 되었다.
- #### Via 헤더
    - 메시지가 지나는 각 중간 노드(프록시나 게이트웨이)의 정보를 (필수적으로) 나열한다.
    - ex. Via: 1.1 proxy-62.irenes-net, 1.0 cache.joes-hardware.com
    - 메세지의 전달을 추적하고, 메세지 루프를 진단하고, 요청-응답의 과정에 관여하는 모든 메세지 발송자들의 프로토콜을 다루는 능력을 알아보기 위해 사용된다.
    - 프록시는 자신의 유니크한 문자열을 via헤더에 삽입하여 요청에 이 문자열이 포함되었는지 검사하는 방식으로, 네트워크 라우팅 루프를 탐지하는 데에 사용되기도 한다. 
    - via 헤더 문법
        - 각 waypoint 마다 프로토콜 이름, 프로토콜 버전, 노드 이름, 노드 코멘트 총 4개의 구성 요소를 담는다.
        - 프로토콜 이름 : 프록시가 받은 프로토콜 명시, HTTP라면 생략 가능.
        - 프로토콜 버전 : 애플리케이션이 자신 이전의 모든 프록시가 어떤 버전을 다룰 수 있는지 확인.
        - 노드 이름 : 프록시의 호스트와 포트 번호. 호스트는 가명으로도 사용 가능.
        - 노드 코멘트 : 벤더나 버전 정보를 포함하며, 장치에서 일어난 이벤트진단 정보를 포함. 선택적인 구성요소.
     - 요청과 응답 경로 : 보통 같은 TCP 커넥션을 오가므로, 응답은 요청과 같은 경로로 되돌아 간다. ( A -> B -> C <=> C -> B -> A)
     - 게이트웨이 : 비HTTP 프로토콜을 사용할 수 있는 게이트웨이 기능 제공
     - 서버 헤더 : 서버헤더는 원 서버에 의해 사용되는 소프트웨어를 알려주며 수정되지 말아야한다. 대신 프록시는 via 항목을 추가한다.
     - via가 개인정보 보호와 보안에 미치는 영향
        - 프록시 서버가 네트워크 방화벽의 일부인 경우 방화벽 뒤의 호스트이름과 포트를 전달해서는 안된다. 이때 보안 경계선인 프록시는 호스트명을 가명으로 교체한다. 단, via 경유시 항목을 유지하려 노력하여야 하며, 이 유지 항목들은 같은 조직하에 가명으로 교체된 호스트이며 수신된 프로토콜이 같다면 하나로 합칠 수 있다. (ex. concealed-stuff)
- #### TRACE 메서드
프록시 서버는 메세지가 전달될때마다 메세지를 바꿀 수 있기 때문에 프록시가 복잡해질 수록 상호운용성 문제가 증가한다. 프록시 네트워크를 진단하기 위해 홉 바이 홉 메세지 내용을 관찰할 방법이 필요하다.
TRACE 메소드는 이런 요청 메세지를 프록시 연쇄를 따라가면서 어떤 프록시를 지나고 어떻게 메세지가 수정되는지 관찰/추적해 디버깅할 수 있도록 해준다. 최종 목적지 서버에 도착하면, 전체 요청 메세지와 프록시 목록 (via 헤더 안의 목록)을 검사할 수 있다. *Contennt-Type : message/http 200 ok
- Max-Forwards : 프록시 홉의 갯수를 제한해 메세지가 무한루프에 빠지지 않는지 체크하거나 프록시 연쇄의 중간에 특정 프록시의 효과를 체크할 때 사용한다. 또한, OPTIONS 메세지의 전달 횟수도 제한할 수 있다. 0인 경우 원 서버가 아니더라도 TRACE메세지를 더이상 전달하지 않고 클라이언트에 돌려줘야 한다.

### 6.7 프록시 인증
제한된 콘텐츠 요청이 프록시에 도착하면 407 Proxy Authorization Required 상태코드와 Proxy-Authenticate 헤더 필드를 함께 반환한다. 이 auth를 수집해 헤더에 담아 다시 요청하면 원 요청을 통과 시키고 그렇지 않으면 407를 반환한다. 프록시 연쇄상에 인증을 요구하는 여러 프록시가 있을 경우 일반적으로 잘 동작하지 않는데, 프록시 연쇄의 특정 경유지와 인증 자격을 확장하는 HTTP 기능은 널리 구현되지는 않았다. (HTTP 인증 메커니즘은 12장 참고)
### 6.8 프록시 상호운용성
프록시 서버는 서로 다른 프로토콜을 구현했을 수도 있는 클라이언트와 서버 사이를 중개해야한다. 
프록시는 이해할 수 없는 헤더 필드를 만나면 반드시 그대로 전달해야하며, 같은 이름의 헤더 필드가 여러개 있느 경우 순서도 반드시 유지해야한다.
- OPTIONS 메소드는 특정 리소스가 어떤 기능/메소드를 지원하는지 클라이언트(혹은 프록시)가 알아볼 수 있게 해준다. * 로 요청 URI를 사용하면 서버 전체의 능력에 대해 묻는 것이 된다. 
- Allow 헤더는 요청 리소스에 대해 서버가 지원하는 모든 메서드를 열거한다. (ex. Allow : GET, HEAD, PUT). 만약 프록시가 모든 메소드를 이해할 수 없더라도 프록시는 Allow 헤더 필드를 수정할 수 없다. 왜냐하면 클라이언트는 원 서버와 대화할 다른 경로를 가지고 있을 수도 있기 때문이다. 

