## 6장 프락시

## 4. 클라이언트 프락시 설정

- 모든 현대적 브라우저들은 프락시 사용에 대해 설정할 수 있음

**수동 설정**

- 프락시를 사용하겠다는 명시적 설정

**브라우저 기본 설정**

- 브라우저 벤더나 배포자는 브라우저를 소비자에게 전달하기 전에 미리 프락시를 설정해 놓을 수 있음

**Proxy auto-configuration (PAC)**

- JavaScript PAC 파일에 대한 URI를 제공할 수 있음
- JS 파일을 통해 클라이언트가 언제 프락시를 쓰는지, 어떤 프락시 서버를 쓰는지 판단하고 실행함

**WPAD(Web Proxy Autodiscovery Protocol) 프락시 발견**

- 대부분의 브라우저들은 자동설정 파일을 다운받을 수 있는 '설정 서버'를 자동으로 찾아주는 WPAD를 제공함

### 4.1 클라이언트 프락시 설정: 수동

- 많은 웹 클라이언트가 프락시를 수동으로 설정할 수 있도록 하고 있음
- Chrome: 설정 > '시스템' 검색 > '컴퓨터 프록시 설정 열기' 클릭
- 브라우저마다 수동 설정에 대한 다른 방법들을 갖고 있지만 아이디어 자체는 같음
- 몇몇 ISP는 미리 설정된 브라우저나 웹 트래픽을 프락시 서버로 리다이렉트하는 맞춤형 운영체제를 구입함

### 4.2 클라이언트 프락시 설정: PAC 파일

- 수동 프락시 설정은 단순하고 유연하지 못함
  - 모든 컨텐츠를 위해 단 하나의 프락시 서버만을 지정할 수 있음
  - 장애 시의 대체 작동에 대한 지원도 없음
  - 설정된 브라우저가 많다면, 모든 브라우저를 원하는 대로 설정을 변경해야 함
- PAC 파일은 보다 동적인 해결책을 제시해줌
  - 상황에 맞게 계산해주는 작은 JS 프로그램이기 때문
  - 문서에 접근할 때마다 JS 함수가 적절한 프락시 서버를 선택함
- PAC 파일 사용을 위해서는 JS PAC 파일의 URI를 브라우저에 설정해야 함
- 설정 이후 브라우저는 URI로부터 PAC 파일을 가져와서 매 접근마다 적절한 프락시 서버를 계산하기 위해 JS 로직을 활용하게 될 것
- PAC 파일은 일반적으로 `.pac` 확장자를 가지며 MIME 타입은 `application/x-ns-proxy-autoconfig`
- 각 PAC 파일은 반드시 URI 접근시 적절한 프락시 서버를 계산해주는 `FindProxyForUrl(url, host)` 함수를 정의해야 함

※ `FindProxyForUrl(url, host)` 함수의 반환값

|   함수 반환값   | 설명                              |
| :-------------: | :-------------------------------- |
|     DIRECT      | 프락시 연결 없이 직접 이루어질 것 |
| PROXY host:port | 지정한 프락시를 사용할 것         |
| SOCKS host:port | 지정한 SOCKS 서버를 사용할 것     |

※ HTTP 트랜잭션과 FRP 트랜잭션에 대해 각각의 프락시를 설정하고, 다른 종류의 트랜잭션은 직접 연결하도록 지시하는 예시

```js
function FindProxyForURL(url, host) {
  if (url.substring(0, 5) == "http:") {
    return "PROXY http-proxy.mydomain.com:8080";
  } else if (url.substring(0, 4) == "ftp:") {
    return "PROXY ftp-proxy.mydomain.com:8080";
  } else {
    return "DIRECT";
  }
}
```

### 4.3 클라이언트 프락시 설정: WPAD

- 웹 프락시 자동발견 프로토콜은 여러 발견 메커니즘들의 상승 전략을 활용해서 브라우저에게 알맞는 PAC 파일을 자동으로 찾아주는 알고리듬
- WPAD 프로토콜이 구현된 클라이언트가 하게 될 일들
  - PAC URI를 찾기 위해 WPAD 사용
  - 주어진 URI에서 PAC 파일을 가져옴
  - 프락시 서버를 알아내기 위해 PAC 파일 실행
  - 알아낸 프락시 서버를 이용해서 요청 처리
- WPAD는 올바른 PAC 파일을 찾기 위해 일련의 리소스 발견 기법을 사용함
  - 여러 기법을 가지고 성공할 때까지 하나씩 기법을 시도해봄
- WPAD 명세에 기록된 기법의 순서
  - DHCP (동적 호스트 발견 규약)
  - SLP (서비스 위치 규약)
  - DNS 잘 알려진 호스트 명
  - DNS SRV 레코드
  - DNS TXT 레코드 안의 서비스 URI

<br>

## 5. 프락시 요청의 미묘한 특징들

- 프락시 서버 요청의 미묘하고도 오해하기 쉬운 측면들
  - 프락시 요청의 URI와 서버 요청의 URI의 차이
  - 인터셉트 프락시와 리버스 프락시가 서버 호스트 정보를 어떻게 감추는지
  - URI 수정 규칙
  - 프락시가 브라우저의 똑똑한 URI 자동완성이나 호스트 명 확장 기능에 어떻게 영향을 줄 수 있는지

### 5.1 프락시 URI는 서버 URI와 다르다

- 웹 서버와 웹 프락시 메시지의 문법은 서로 같지만, 요청의 URI는 다름

※ 클라이언트가 웹 서버로 요청을 보낼 때는 스킴, 호스트, 포트번호가 없는 부분 URI를 가짐

```
GET /index.html HTTP/1.0
User-Agent: SuperBrowser v1.3
```

※ 클라이언트가 프락시로 요청을 보낼 때는 완전한 URI를 가짐

```
GET http://www.marys-antique.com/index.html HTTP/1.0
User-Agent: SuperBrowser v1.3
```

Q. 이러한 차이가 생기는 이유는?

- 기존 HTTP 설계에서, 클라이언트는 서버하고만 직접 대화를 했음
  - 가상 호스팅이 아직 존재하지 않았고, 프락시에 대한 대비도 없었음
- 단일 서버와 직접 대화할 경우에는 서버가 자신의 호스트 명과 포트번호를 알고 있음
  - 따라서 클라이언트는 불필요한 정보 발송을 피하기 위해 **부분 URI**를 보낼 수 있는 것
- 프락시가 떠오르면서, 부분 URI는 문제가 되었음
  - 프락시는 목적지 서버와 커넥션을 맺어야 하기 때문에 서버의 이름을 알 필요가 있었음
  - 또 프락시 기반 게이트웨이는 FTP 리소스 혹은 그 외 스킴과의 연결을 위해 URI의 스킴을 알 필요가 있었음
- 그래서 HTTP/1.0, HTTP/1.1 은 서버들이 완전한 URI를 다룰 것을 요구함
  - 그러나 현실적으로 이미 너무 많은 기존 서버들이 배치되어 있어서, 여전히 많은 서버들이 부분 URI만을 받아들이고 있음
- 그렇기에 우리는 서버로는 부분 URI를, 프락시로는 완전한 URI를 보낼 필요가 있는 것
- 클라이언트가 프락시에 대해 명시적으로 설정해두었을 경우에는 어떻게 요청을 보낼지 스스로 알고 있음
  - 클라이언트가 프락시를 사용하지 않도록 설정했다면, 부분 URI를 보냄
  - 클라이언트가 프락시를 사용하도록 설정했다면, 완전 URI를 보냄

<img width="503" alt="요청 URI의 변경" src="https://user-images.githubusercontent.com/75058239/199850780-b70c7b56-0f4a-4a22-bf39-81433602b788.png">

### 5.2 가상 호스팅에서 일어나는 같은 문제

- 부분 URI를 사용할 때 생기는 문제는 가상으로 호스팅되는 웹 서버에도 발생함
- 가상 호스팅 웹 서버는 여러 웹 사이트가 동일한 물리적 웹 서버를 공유함
  - 따라서 요청 하나가 부분 URI로 오면, 가상 호스팅 웹 서버는 요청이 접근하고자 하는 웹 사이트의 호스트 명을 알 필요가 있음
- 이에 대한 2가지 해결책
  - 명시적인 프락시를 활용해서, 요청 메시지가 완전한 URI를 갖도록 함
  - 호스트와 포트에 대한 정보가 담겨 있는 Host 헤더를 요구

### 5.3 인터셉트 프락시는 부분 URI를 받는다

- 클라이언트는 명시적으로 설정된 프락시에게 완전한 URI를 줄 것
- 하지만 클라이언트는 자신이 프락시와 대화하고 있음을 항상 아는 것이 아님 (몇몇 프락시는 클라이언트에게 보이지 않을 수 있기 때문에)
- 설령 클라이언트가 프락시 사용 설정을 안 해두어도, 트래픽은 여전히 대리 프락시나 인터셉트 프락시를 지날 수도 있음
  - 두 가지 경우 모두, 클라이언트는 자신이 웹 서버와 대화하고 있다고 생각하고 부분 URI를 보내게 될 것
- 두 프락시가 하게 될 일
  - 대리 프락시는 원 서버의 호스트 명과 IP 주소를 이미 가지고 있음
  - 인터셉트 프락시는 트래픽을 가로채서 캐시된 응답을 돌려줌

### 5.4 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있다

- 트래픽이 프락시 서버로 리다이렉트될 수 있는 여러 방법들이 존재하기 때문에,<br>다목적 프락시 서버는 완전 URI와 부분 URI를 모두 지원해야 함

⭐ 프락시가 완전 URI와 부분 URI를 다루는 규칙

- 완전 URI가 주어졌다면 그것을 사용할 것
- 부분 URI가 주어졌고 Host 헤더가 있다면 Host 헤더를 통해 원 서버를 알아낼 것
- 부분 URI가 주어졌는데 Host 헤더도 없다면 다음 방법들을 동원해서 원 서버를 알아내야 함
  - 대리 프락시의 경우에는 프락시에 원 서버의 주소와 포트번호가 설정되어 있을 것
  - 이전에 인터셉트 프락시가 받은 트래픽을 통해서 서버 주소와 포트번호를 사용할 수 있도록 해두었다면 이를 활용할 수 있음
  - 모두 실패했다면 프락시는 충분한 정보를 갖고 있지 못한 것이므로 에러 메시지를 반환해야 함 (보통은 Host 헤더를 지원하는 현대 브라우저 사용을 권장)

### 5.5 전송 중 URI 변경

- 사소한 URI 변경이라도 다운스트림 서버와 상호운용성 문제를 일으킬 수 있으므로 주의해야 함
- 특히 몇몇 프락시는 URI를 다음 hop으로 보내기 전에 표준 형식으로 '정규화'를 하고 있음
- 기본 HTTP포트 ':80'을 명시적으로 붙여주는 등의 무해해 보이는 변형이라 해도 상호운용성 문제를 일으킬 수 있음
- 일반적으로 프락시 서버는 가능한 한 관대해야 하며, 프로토콜 준수를 강요하는 프로토콜 경찰처럼 되어서는 안됨
- 특히 HTTP 명세는 인터셉트 프락시가 절대 경로를 고치는 것을 금지함
  - 유일한 예외는 빈 경로를 `/`로 교체할 때뿐

### 5.6 URI 클라이언트 자동확장과 Hostname Resolution

- 프락시가 없다면 브라우저는 사용자가 타이핑한 URI에 대응하는 IP 주소를 찾아냄
- 호스트를 찾아낼 수 없을 때는 자동화된 호스트 명 '확장'을 시도함
  - `www.` 접두사와 `.com` 접미사를 붙여줌
  - 심지어 URI를 서드파티 사이트로 넘겨서 오타 교정을 시도하는 브라우저들도 있음
  - DNS는 사용자가 호스트 명의 앞부분만 입력하면 자동으로 도메인을 검색하도록 설정되어 있음

### 5.7 프락시 없는 URI Resolution

![URI 분석](https://user-images.githubusercontent.com/75058239/200095916-1445c5aa-b1f2-467e-bddc-57e228e19fe5.png)

- 브라우저는 유효한 호스트 명이 발견될 때까지 다양한 호스트 명의 가능성들을 검색함

### 5.8 명시적인 프락시를 사용할 때의 URI Resolution

![명시적 프락시와 URI 분석](https://user-images.githubusercontent.com/75058239/200095925-39caa362-8c1a-4e67-be0e-bc0000c51d1c.png)

- 명시적인 프락시를 사용한다면 브라우저는 이 편리한 확장 기능들을 사용할 수 없음
  - 브라우저의 URI가 프락시를 그냥 지나쳐버리기 때문
- 이 때문에 몇몇 프락시는 `www.` `.com` 자동확장이나 지역 도메인 접미사 추가 등의 기능을 최대한 흉내 내려고 시도함
  - 그러나 프락시는 광범위하게 사용되고 있기에, 개개인들 모두에게 맞는 도메인 접미사를 알아내는 것은 불가능할 것

### 5.9 인터셉트 프락시를 이용한 URI Resolution

![인터셉트 프락시와 URI 분석](https://user-images.githubusercontent.com/75058239/200095930-46423352-6694-4cd2-bb81-1290c40148ed.png)

- 보이지 않는 인터셉트 프락시를 사용한다면 또 얘기가 달라짐
- 브라우저 입장에서 프락시는 존재하지 않는 것이기 때문에 호스트 명 자동확장을 계속 수행하게 될 것
- 만약 클라이언트가 DNS 서버를 통해 유효한 IP 주소를 찾아냈지만, 실제론 서버가 죽어 있는 경우에 골치가 아파짐
  - 죽은 서버 IP에 대한 첫번째 접속은 우선 원 서버가 아닌 프락시 선에서 종료될 것
  - 그런데 프락시는 진짜 원 서버와 상호작용할 준비가 되었을 때 해당 IP 주소가 죽은 서버를 가리키고 있음을 알게 될 것
  - 프락시는 브라우저와 동등한 수준의 **fault tolerance**를 제공하기 위해서 다른 IP 주소를 찾아내고 시도해야 함
- 명시적인 프락시와 인터셉트 프락시 모두 죽은 서버의 DNS 분석에 대한 fault tolerance를 지원하는 것이 중요한 포인트
