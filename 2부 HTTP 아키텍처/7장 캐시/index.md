## 7장 캐시



### 7.6 캐시 토폴로지
- 캐시는 한 명의 사용자에게만 할당될 수도 있고(개인 전용 캐시) 반대로 수천 명의 사용자들 간에 공유될 수도 있다.(공용캐시)
- 개인 전용 캐시는 한 명의 사용자가 자주 찾는 페이지를 담고, 공공용 캐시는 사용자 집단에게 자주 쓰이는 페이지를 담는다.

#### 7.6.1 개인 전용 캐시
- 대부분의 브라우저는 개인 전용 캐시를 내장하고 있고, 자주 쓰이는 문서를 로컬의 디스크와 메모리에 캐시해두고 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용
- 캐시에 담긴 데이터를 확인하는 것도 가능

#### 7.6.2 공용 프락시 캐시
- 공용 캐시는 캐시 프락시 서버 혹은 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버다. 
- 프락시 캐시는 로컬 캐시에서 문서를 제공하거나 사용자 입장에서 서버에 접근
- 여러 사용자가 접근하기 때문에 불필요한 트래픽을 줄일 수 있는 더 많은 기회가 있다.

- 프락시 캐시는 프락시를 위한 규칙에 따른다.
- 수동 프락시를 지정하거나 프락시 자동설정 파일을 설정함으로써 브라우저가 프락시 캐시를 사용하도록 설정할 수 있다.
- 인터셉트 프락시를 사용함으로써 브라우저의 설정 없이 HTTP 요청이 캐시를 통하도록 강제할 수 있다.

#### 7.6.3 프락시 캐시 계층들
- 작은 캐시에서 캐시 부적중이 발생했을 때 부모 캐시가 걸러 남겨진 트래픽을 처리하도록 하는 계층구조를 말한다.
- 클라이언트 주위에는 작고 저렴한 캐시를, 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하는 크고 강력한 캐시를 사용하자는 것이다.
- 계층이 깊으면 요청은 캐시의 긴 연쇄를 따라가게 될 것이고, 이런 프락시 연쇄가 길어질 수록 현저한 성능 저하가 발생한다.

#### 7.6.4 캐시망, 콘텐츠라우팅, 피어링
- 어떤 네트워크 아키텍처는 복잡한 캐시망을 만든다.
- 캐시망 안에서 콘텐츠 라우팅을 위해 설계된 캐시들은 다음과 같은 일들을 할 수 있다.

> - URL에 근거해, 부모 캐시와 원 서버 중 하나를 동적으로 선택
> - URL에 근거해 특정 부모 캐시를 동적으로 선택
> - 부모 캐시에게 가기 전, 캐시된 사본을 로컬에서 검색
> - 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 트랜짓은 허용하지 않는다.

- 이런 복잡한 캐시 사이의 관계는 서로 다른 조직들이 상호 이득을 위해 그들의 캐시를 연결해 서로를 찾아볼 수 있도록 한다.
- HTTP는 형제 캐시를 지원하지 않기 때문에, 인터넷 캐시 프로토콜(ICP)이나 하이퍼텍스트 캐시 프로토콜(HTCP) 같은 프로토콜을 이용해 HTTP를 확장했따.


### 7.7 캐시 처리 단계

> 1. 요청 받기
> 2. 파싱
> 3. 검색
> 4. 신선도 검사
> 5. 응답 생성
> 6. 발송
> 7. 로깅

  1. 요청받기
  - 캐시는 네트워크 커넥션에서의 활동을 감지, 들어오는 데이터를 읽어온다.
  - 고성능 캐시는 여러개의 커넥션으로부터 동시에 데이터를 읽고 메시지 전체가 도착 전 트랜잭션 처리를 시작한다.

  2. 파싱
  - 캐시는 요청 메시지를 여러 부분으로 파싱해 헤더 부분을 조작하기 쉬운 자료구조에 담는다. 

  3. 검색
  - 캐시는 URL을 알아내고 그에 해당하는 로컬 사본이 있느지 검사.
  - 로컬 복사본은 메모리, 디스크 혹은 다른 컴퓨터에 있을 수도 있다. 
  - 전문적인 수준의 캐시는 객체를 로컬 캐시에서 가져올 수 있는지 판단하기 위해 빠른 알고리즘을 사용.
  - 만약 문서를 로컬에서 가져올 수 없으면 상황이나 설정에 따라 원서버나 부모 프락시에서 가져오거나 혹은 실패를 반환.

  4. 신선도 검사
  - HTTP는 캐시가 일정 기간동안 서버 문서의 사본을 보유할 수 있도록 한다.
  - 이 기간동안 문서는 '신선'한 것으로 간주, 캐시는 서버와 접촉없이 이 문서를 제공한다.
  - 신선도 한계를 넘어설 정도로 오래 갖고 있으면 그 객체는 '신선하지 않은' 것으로 간주, 캐시는 문서 제공 전 문서에 어떤 변경이 있었는지 검사하기 위해 서버와 재검사.
  - 신선도 검사 규칙 이 장 나머지의 대부분에 거쳐 설명.

  5. 응답 생성
  - 캐시된 응답을 원 서버에서 온 것 처럼 보이게 하기 위해 캐시는 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성.
  - 캐시는 클라이언트에 맞게 이 헤더를 조정해야 하는 책임이 있따.
  - 예를 들어, 클라이언트가 HTTP/1.1 응답을 기대하는 상황에서 서버가 HTTP/1.0 응답을 반환했다면 캐시는 반드시 헤더를 적절하게 번역해야 한다.
  - 캐시 신선도 정보(Cache-Control, Age, Expires 헤더)와 요청이 프락시 캐시를 거쳐갔음을 알려주기 위해 Via헤더를 포함시킨다.
  - 캐시가 Date 헤더를 조정해서는 안된다. Date 헤더는 그 객체가 원 서버에서 최초로 생겨난 일시이다.

  6. 전송
  - 응답 헤더가 준비되면 캐시는 응답을 클라이언트에게 돌려준다.
  - 모든 프락시 서버들과 마찬가지로, 프락시 캐시는 클라이언트와의 커넥션을 유지할 필요가 있음.
  - 고성능 캐시는 종종 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서의 콘텐츠 복사를 피함으로써 데이터를 효과적으로 전송하기 위해 노력한다.

  7. 로깅
  - 대부분의 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지한다.
  - 각 캐시 트랜잭션이 완료된 후, 캐시는 통계 캐시 적중과 부적중 횟수(그외 다른 관련 지표들)에 대한 통계를 갱신, 로그 파일에 요청 종류와 URL, 그리고 무엇이 일어났는지 알려주는 항목을 추가.
  - 가장 많이 쓰이는 캐시 로그 포맷은 스쿼드 로그 포맷과 넷스케이프 확장 공용 로그 포맷. 많은 캐시 제품이 커스텀 로그 파일을 허용한다.
  
  8. 캐시 처리 플로우 차트

  <img width="758" alt="캐시 GET 요청 플로우 차트" src="https://user-images.githubusercontent.com/87509645/201481003-8d373e68-e6a5-4948-8b9b-2eab3e6dcf6a.png">
