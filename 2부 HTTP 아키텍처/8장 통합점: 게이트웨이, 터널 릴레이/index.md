## 8장 통합점: 게이트웨이, 터널, 릴레이

### 8.1 게이트웨이
  웹에 더 많은 리소스를 올려야 할 필요가 생기면서, 모든 리소스를 한 개의 애플리케이션에서 처리할 수 없다는 것이 분명해졌다. 이 문제에 대한 해결책으로, 인터프리터같이 리소스를 받기 위한 경로를 안내하는 역할을 하는 게이트웨이를 고안했다. 게이트웨이는 HTTP 트래픽을 다른 프로토콜로 자동으로 변환하여, HTTP 클라이언트가 다른 프로토콜을 알 필요없이 서버에 접속할 수 있게 하기도 한다.
### 8.2 프로토콜 게이트웨이
  브라우저에 명시적으로 게이트웨이를 설정해서 자연스럽게 트래픽이 게이트웨이를 거쳐가게 하거나, 게이트웨이를 대리 서버(리버스 프록시)로 설정할 수 있다.
  - 서버측 웹 게이트웨이는 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환한다. (ex.FTP)
  - 내부 웹 요청을 암호화함으로써 개인 정보 보호와 보안을 제공하는데에 게이트웨이를 사용할 수 있다. 클라이언트는 일반 HTTP를 사용해 웹을 탐색하지만, 게이트웨이는 자동으로 클라이언트의 모든 세션을 암호화 할 수 있다.
  - HTTPS/HTTP 게이트웨이는 웹 서버의 앞단에서 보안HTTPS 트래픽으로 받아서 복화하고, 웹 서버로 보낼 일반 HTTP 요청을 만든다. 이는 보안 트래픽을 효율적으로 복호화하는 암호화 하드웨어를 내장해서 원 서버의 부하를 줄여주기도 한다. 단, 게이트웨이와 원서버 사이에 암호화하지 않은 트래픽을 전송하기 때문에 네트워크가 안전한지 확실히 확인이 필요하다.
### 8.3 리소스 게이트웨이
- 공용 게이트웨이 인터페이스(CGI) : 게이트웨이를 통해야 받을 수 있는 리소스 요청 - 헬퍼 애플리케이션 생성, 요청 처리 - 서버로부터 응답을 받아 - 클라이언트로 반환. 서버와 게이트웨이는 별개의 애플리케이션이기 때문에 각각 가지고 책임은 분명히 나뉘어있다. 이 단순한 프로토콜은 가장 오래되고 널리쓰이는 서버 확장 인터페이스다.
   - 장점 : 1)CGI가 내부에서 어떤 처리를 하는지 사용자에게 노출하지 않는다. 2)모든 리소스, 서버와의 접점에 있으면서 필요에 따라 변형 처리를 해낸다. 3)원 서버를 보호한다.
   - 단점 : 원서버와의 분리때문에 성능관련 비용이 발생한다. 2) 모든 CGI 요청마다 새로운 프로세스를 만드는 데 따르는 부하가 크다. -> demon으로 동작하는 Fast CGI 개발로 성능 문제를 해결 
### 8.4 애플리케이션 인터페이스와 웹 서비스
애플리케이션을 연결하면서 생기는 까다로운 이슈 중 하나는 , 데이터를 교환하려는 두 앱 사이에서 프로토콜 인터페이스를 맞추는 일이다. 이때 사용되는 것이 웹서비스의 표준 HTTP 프로토콜이며, 모든 웹은 웹 표준 기술인 HTTP 위에서 개발된다.

### 8.5 터널
- 웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공한다.
- 웹 터널을 이용하면 HTTP 커넥션을 통해 HTTP가 아닌 트래픽을 전송할 수 있고, 다른 프로토콜을 HTTP 위에 올릴 수 있다.
- 웹 터널을 사용하는 가장 일반적인 이유는 **HTTP 커넥션 안에 HTTP가 아닌 트래픽을 얹기 위해**서다. 따라서 웹 터널을 사용하면 웹 트래픽만을 허용하는 방화벽이 있더라도 HTTP가 아닌 트래픽을 전송할 수 있다.

#### 8.5.1 CONNECT로 HTTP 터널 커넥션 맺기
- 웹 터널은 HTTP CONNECT 메서드를 사용해 커넥션을 맺는다.
  - CONNECT 메서드는 터널 게이트웨이가 임의의 목적 서버와 포트에 TCP 커넥션을 맺고 클라이언트와 서버 간에 오는 데이터를 무조건 전달하기를 요청.

- CONNECT 요청
CONNECT 문법은 시작줄을 제외하면 다른 HTTP 메서드와 같다. 요청 URI는 호스트 명이 대신하며 콜론에 이어 포트를 기술. 
```http
CONNECT home.netscape.com:443 HTTP/1.0
User-agent: Mozilla/5.0

```
시작줄 다음에는 다른 HTTP 메시지와 같이, 추가적인 HTTP요청 헤더 필드가 있거나 없다. 

- CONNECT 응답
일반적인 HTTP 응답과 달리 커넥션이 메시지를 전달하는 대신 바이트를 그대로 전달하기 때문에 콘텐츠의 형식을 기술하는 `Content-Type` 헤더를 포함할 필요가 없다.
```http
HTTP/1.0 200 Connection Established
Proxy-agent: Netscape-Proxy/1.1

```

#### 8.5.2 데이터 터널링, 시간, 커넥션 관리
- 클라이언트는 성능을 높이기 위해 CONNECT 요청을 보낸 다음, 응답을 받기 전에 터널 데이터를 전송할 수 있다.(게이트웨이가 요청에 이어 데이터를 적절하게 처리할 수 있어야 함)
- 커넥션이 끊어지면 끊어진 곳으로부터 온 데이터는 반대편으로 전달
- 커넥션이 끊긴 한쪽에 아직 전송하지 않은 데이터는 버려짐

#### 8.5.3 SSL 터널링
- 웹 터널은 원래 방화벽을 통해 암호화된 SSL 트래픽을 전달하려고 개발
- 하지만 SSL 같이 암호화된 프로토콜은 정보가 암호화 되어 있어 낡은 방식의 프락시에서는 처리되지 않는다.
- SSL 트래픽이 기존 프락시 방화벽을 통과할 수 있도록 HTTP에 터널링 기능이 추가.
- HTTP 메시지에 암호화된 **날 데이터**를 담고 일반 HTTP 채널을 통해 데이터를 전송.
- 보안 SSL 트래픽이 방화벽을 통과하는데 유용하지만 악의적인 트래픽이 사내로 유입되는 경로가 될 수도 있다.

#### 8.5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이
- HTTP/HTTPS 게이트웨이
  1. 클라이언트-게이트웨이 사이에는 보안이 적용되지 않은 일반 HTTP 커넥션이 맺어져 있다.
  2. 프락시가 인증을 담당하고 있기 때문에, 클라이언트는 원격 서버에 SSL 클라이언트 인증(X509 인증서 기반의 인증)을 할 수 없다.
  3. 게이트웨이는 SSL을 완벽히 지원해야 함.

- SSL 터널링
  - 프락시에 SSL을 구현할 필요가 없다. 
  - SSL 세션은 클라이언트가 생성한 요청과 목적지(보안이 적용된) 웹 서버 간에 생성
  - 프락시 서버는 트랜잭션의 보안에는 관여하지 않고 암호화된 데이터를 그대로 터널링 할 뿐

#### 8.5.5 터널 인증
- HTTP의 다른 기능들은 터널과 함께 적절히 사용할 수 있다. 예를들면 프락시 인증 기능은, 클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널에서 사용할 수 있다.

#### 8.5.6 터널 보안에 대한 고려사항들
- 터널 게이트웨이는 통신하고 있는 프로토콜이 터널을 올바른 용도로 사용하고 있는지 검증할 방법이 없다.
- 때문에 특정 포트만을 터널링 할 수 있게 하는 등의 정책과 함께 사용하는 것을 권장

### 8.6 릴레이
- HTTP 릴레이는 HTTP 명세를 완전히 준수하지는 않는 간단한 HTTP 프락시
- 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 맹목적으로 전달.
- 간단하게 구현할 수 있어 단순 필터링이나 진단, 콘텐츠 변환을 하는데 유용하지만 잠재적으로 심각한 상호 운용 문제를 갖고 있다.
- 대표적으로 릴레이가 Connection 헤더를 제대로 처리 못해 Keep-Alive 커넥션이 행에 걸리는 것이다.

