## 15장 엔터티와 인코딩

- HTTP는 메시지가 올바르게 수송, 식별, 추출, 처리되는 것을 보장하기위해 콘텐츠를 나르기 위한 잘 라벨링된 엔터티를 사용한다.

## 1. 메시지는 컨테이너, 엔터티는 화물

- HTTP 메시지를 인터넷 운송 시스템의 컨테이너라고 생각한다면, HTTP 엔터티는 메시지의 실질적 화물이다.
- Content-Type, Content-Length, Content-Language, Content-Encoding, Content-Location, Content-Range, Content-MD5, Last-Modified, Expires, Allow, Etag, Cache-Control

### 1.1 엔터티 본문

- 엔터티 본문은 가공되지 않은 데이터만을 담고 있다. 가공되지 않은 데이터이기 때문에 엔터티 헤더는 데이터의 의미에 대해 설명할 필요가 있다.
- 엔터티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작한다.

## 2. Content-Length: 엔터티의 길이

- Content-Length 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타낸다. 메시지를 청크 인코딩으로 전송하지 않는 이상, 엔터티 본문을 포함한 메시지에서는 필수적으로 있어야 한다.
- 서버 충돌로 인해 메시지가 잘렸는지 감시하고자 할 때와 지속 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요

### 2.1 잘림 검출

- Content-Length가 없으면 클라이언트는 커넥션이 정상적으로 닫힌 것인지 서버에 충돌이 발생한 것인지 구분하지 못한다. 따라서 메시지 잘림을 검출하기 위해 Content-Length를 필요로 한다.
- 메시지 잘림은 캐싱 프락시 서버에서 특히 취약하다. 캐시가 잘린 메시지를 수신했으나 잘렸다는 것을 인식하지 못한 경우, 캐시는 결함이 있는 콘텐츠를 저장하고 계속해서 제공하게 되므로 이를 방지하기 위해 캐싱 프락시 서버는 Content-Length 헤더를 갖고 있지 않은 HTTP 본문은 보통 캐시하지 않는다.

### 2.2 잘못된 Content-Length

- Content-Length가 잘못된 값을 담지 않도록 HTTP/1.1 사용자 에이전트는 잘못된 길이를 인지했을 때 사용자에게 알려주게 되어 있다.

### 2.3 Content-Length와 지속 커넥션(Persistent Connection)

- 지속된 커넥션을 위하여 Content-Length는 필수이고 지속된 커넥션 하에 커넥션이 닫힌 위치를 근거로 메시지의 끝을 인식하는 것은 불가능하다. 또한 HTTP 애플리케이션은 엔터니 본문과 다음 메시지의 구분을 하지 못한다.
- 청크 인코딩을 사용한 경우 엔터티 전체 크기를 알 수 없더라도 전송할 수 있다.

### 2.4 콘텐츠 인코딩

- HTTP 보안을 강화하거나 압축을 통해 공간을 절약 할 수 있도록, 엔터티 본문을 인코딩할 수 있게 한다. 콘텐츠가 인코딩이 된 경우, 원본 길이가 아닌 인코딩 후의 길이로 본문의 길이를 바이트 단위로 정의한다.

### 2.5 엔터티 본문 길이 판별을 위한 규칙

1. 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP메시지에서는 본문계산을 위한 Content-Length 헤더가 무시된다. 예를들어 HEAD 응답의 경우 본문을 갖지 않기에 반드시 헤더 이후의 첫번째 빈 줄에서 끝나야 한다.
2. Transfer-Encoding 헤더를 포함고 있으면 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 '0 바이트 청크'라 부르는 특별한 패턴으로 끝나야 한다.
3. Transfer-Encoding 헤더 필드를 갖고 있는 메시지를 받았다면 반드시 Content-Length 헤더를 무시해야 하는데, 전송 인코딩이 엔터티 본문을 표현하고 전송하는 방식을 바꿀 것이기 때문이다.
4. 'multipart/byteranges' 미디어 타입을 사용하는 멀티파트 유형은 스스로의 크기를 결정할 수 있는 유일한 엔터티 본문 유형이다.
5. 위 규칙에 해당되지 않으면 엔터티는 커넥션이 닫힐 때 끝나며 서버만이 커넥션을 닫을 수 있다.
6. HTTP/1.0 애플리케이션과 호환을 위해 엔터티 본문을 갖고 있는 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더도 갖고 있어야 한다.

## 3. 엔터티 요약

- 엔터티 본문 데이터에 대한 의도하지 않은 변경을 감지하기 위해, 최초 엔터티 생성시 송신자는 데이터에 대한 체크섬을 생성할 수 있고 수신자는 그 체크섬으로 기본적인 검사를 할 수 있다.
- 메시지의 무결성을 검증하려는 클라이언트는 먼저 전송 인코딩을 디코딩 한 뒤 그 디코딩 된 엔터티 본문에 대한 MD5 계산을 하여 검증을 한다.
- MD5는 문서의 위치를 알아내고 콘텐츠의 중복 저장을 방지하기 위한 해시 테이블의 키로 이용될 수 있다.

## 4. 미디어 타입과 차셋(Charset)

- Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다. 주 미디어 타입과 빗금, 구체적인 미디어 타입을 서술하는 부 타입으로 구성된다.
- 엔터티가 콘텐츠 인코딩을 거친 경우에도 Content-Type 헤더는 여전히 인코딩 전의 엔터티 본문 유형을 명시할 것이다.

### 4.1 텍스트 매체를 위한 문자 인코딩

- 엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 'charset' 매개변수는 Content-Type 헤더가 내용 유형을 더 자세히 지정하기 위한 대표적인 예이다.

### 4.2 멀티파트 미디어 타입

- MIME 멀티파트 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내진다. 각 구성요소는 자신을 서술하는 헤더를 포함하고 문자열 하나로 서로의 경계가 식별된다.

### 4.3 멀티파트 폼 제출

- HTTP 폼 제출 시, 텍스트 필드와 업로드 될 객체는 각각 멀티파트 본문을 구성하는 하나의 파트가 되어 보내진다.
- 멀티파트 본문은 여러 다른 종류/길이의 값으로 채워진 폼을 허용하는데, 이러한 경우 `Content-type: multipart/mixed` 또는 `Content-type: multipart/form-data` 헤더에 멀티파트 본문을 함께 보낸다.
  `Content-type: multipart/form-data; boundary=[abcdefghijk]`
- boundary는 본문의 서로 다른 부분을 구분하기 위한 구분자로 쓰인다.

### 4.4 멀티파트 범위 응답

- 범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수도 있다. 그런 응답은 Content-type: multipart/byteranges 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 온다.

## 5. 콘텐츠 인코딩
- 서버, 즉 발송하는 쪽에서 전송시간 단축을 위한 압축, 콘텐츠 암호화를 위한 인코딩을 하고, 인코딩이 끝난 콘텐츠를 엔티티 본문에 담아 클라이언트에 보낸다.

### 5.1 콘텐츠 인코딩 과정
1. 웹서버가 원본 Content-Type과 Content-Length 헤더를 바탕으로 원본 응답 메세지를 생성한다.
2. 콘텐츠 인코딩 서버가 인코딩된 메세지를 생성한다. 인코딩된 메세지는 Content-Type은 같지만 Content-Length는 다를 수 있다. 콘텐츠 인코딩 서버는 Content-Encoding 헤더를 메세지에 추가해 클라이언트에서 디코딩할 수 있도록 한다.
3. 클라이언트는 인코딩된 메세지를 받아 디코딩해 원본 콘텐츠를 얻는다.

### 5.2 콘텐츠 인코딩 유형
- HTTP는 표준 인코딩 유형 + 확장 인코딩도 허용한다. (IANA : 인코딩 알고리즘에 고유한 토큰을 할당하는 IANA를 통해 표준화된다. ex. gzip, compress, deflate -> 무손실 압축 알고리즘, identity -> Content-Encoding 헤더가 없으면 어떤 인코딩도 수행되지 않았음을 의미한다. )

### 5.3 Accept-Encoding 헤더
- 클라이언트는 서버가 해독할 수 없는 방법으로 인코딩하지 않도록 클라이언트가 지원하는 인코딩 목록을 Accept-Encoding 요청 헤더에 , 로 구분해 전달한다.
- 헤더가 없을시 * 와 같이 어떤 인코딩도 허용하게 된다. q=0.0 ~ q=1.0 까지 선호도를 표시해 전달 할 수 있다.

## 6. 전송 인코딩과 청크 인코딩
- 콘텐츠 인코딩은 콘텐츠 포맷과 긴밀하게 연관되어 있다.
- 전송 인코딩 : 콘텐츠 인코딩과 다르게 콘텐츠의 포맷과 독립적이며, 메세지 데이터가 네트워크를 통해 전송되는 방법을 바꾸기 위해 전송 인코딩을 메세지에 적용할 수 있다. 콘텐츠 인코딩된 메세지는 엔티티 부분만 인코딩하는 반면, 전송 인코딩은 전체 메세지에 적용되어 메제시 자체의 구조를 바꾼다.

### 6.1 안전한 전송
- 전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 '안전한 전송'을 위해 존재해왔다. HTTP 전송된 메세지 본문에서 문제를 일으키는 것은 몇 가지 밖에 없는데, 그 중 두가지는 아래와 같다.
   - 알 수 없는 크기 : 몇몇 게이트웨이 앱과 콘텐츠 인코더는 콘텐츠를 생성하지 전에는 메제시 본문의 최종 크기를 판단할 수 없다. 몇몇 서버는 데이터의 끝을 알리는 CRLF을 포함시켜 전송 인코딩으로 데이터를 보내려 시도한다.
   - 보안 : 전송 인코딩으로 알아보기 어렵게 뒤섞어버리는 경우. 그러나 SSL과 같은 전송 계층 보안 방식으로 흔하게 발생하지는 않는다.
   
### 6.2 Transfer-Encoding 헤더
- Transfer-Encoding : 안전한 전송을 위해 어떤 인코딩이 메세지에 적용되었는지 클라이언트에 알려준다.
- TE : 어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에 알려주기 위해 요청 헤더에 사용한다. q값 사용 가능하나 HTTP/1.1명세에서는 0.0을 갖는 것을 금지한다.

### 6.3 청크 인코딩
- 청크 인코딩은 메세지를 일정 크기의 청크 여럿으로 쪼개고 서버는 각 청크를 순차적으로 보낸다. 
- 청크 인코딩을 이용하면 메세지를 보내기 전에 전체 크기를 알 필요가 없어지는데, 본문이 동적으로 생성됨면 서버는 그중 일부를 버퍼에 담은 뒤 한 청크를 그 크기와 함께 보낼 수 있다. 본문 전체를 모두 보낼 때까지 이 단계를 반복한다. 마지막 청크는 크기가 0이며, 이로써 본문이 끝났음을 알리고 다음 응답을 위해 커넥션을 열린 채로 유지할 수 있다.

#### 청크와 지속 커넥션
클라이언트와 서버 사이의 커넥션이 지속적이지 않다면, 클라이언트는 자신이 읽고 있는 본문의 크기를 알 필요가 없다. 서버가 커넥션을 닫을 때까지 본문으로 간주하고 읽을 것이다. 

#### 청크 인코딩된 메세지의 트레일러
다음 중 하나 이상의 조건을 만족하면 청크 메세지에 트레일러를 추가할 수 있다.
- 클라이언트의 TE헤더가 트레일러를 받아들일 수 있음을 나타내고 있는 경우
- 트레일러가 응답을 만든 서버에 의해 추가되었으며, 그 트레일러 콘텐츠가 클라이언트가 이해하고 사용할 필요가 없는 선택적인 메타데이터이므로 클라이언트가 무시하고 버려도 되는 경우
- 메세지 헤더는 청크 인코딩된 메세지 다음에 오게 될 헤더를 나열하는 트레일러 헤더를 포함한다.

### 6.4 콘텐츠와 전송 인코딩의 조합
- 콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다.

### 6.5 전송 인코딩 규칙
- 전송 인코딩의 집합은 반드시 'chunked'를 포함해야 한다. 유일한 예외는 메세지가 커넥션의 종료로 끝나는 경우.
- 청크 전송 인코딩이 사용되었다면, 메세지 본문에 적용된 마지막 인코딩이 존재해야 한다.
- 청크 전송 인코딩은 반드시 메세지 본문에 한 번 이상 적용되어야 한다.
이 규칙은 클라이언트가 메세지의 전송 길이를 알아낼 수 있게 해준다.

## 7. 시간에 따라 바뀌는 인스턴스
웹 객체는 정적이지 않다. 같은 URL은 시간에 따라 다른 버전의 객체(인스턴스)를 가리킬 수 있다. 
- HTTP 프로토콜은 특정 종류의 요청이나 응답을 다루는 방법들을 정의하는데, 이것을 인스턴스 조작이라 하며 객체의 인스턴스에 작용한다.
- ex. 범위 요청, 델타 인코딩 : 클라이언트가 자신이 갖고 있는 리소스 사본이 서버가 갖고 있는 것과 정확히 같은지 판단하고, 상황에 따라 새 인스턴스를 요청할수 있는 능력을 가질 것을 요구한다. 
