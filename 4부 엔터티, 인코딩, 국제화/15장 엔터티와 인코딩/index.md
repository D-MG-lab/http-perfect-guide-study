## 15장 엔터티와 인코딩

- HTTP는 메시지가 올바르게 수송, 식별, 추출, 처리되는 것을 보장하기위해 콘텐츠를 나르기 위한 잘 라벨링된 엔터티를 사용한다.

## 1. 메시지는 컨테이너, 엔터티는 화물

- HTTP 메시지를 인터넷 운송 시스템의 컨테이너라고 생각한다면, HTTP 엔터티는 메시지의 실질적 화물이다.
- Content-Type, Content-Length, Content-Language, Content-Encoding, Content-Location, Content-Range, Content-MD5, Last-Modified, Expires, Allow, Etag, Cache-Control

### 1.1 엔터티 본문

- 엔터티 본문은 가공되지 않은 데이터만을 담고 있다. 가공되지 않은 데이터이기 때문에 엔터티 헤더는 데이터의 의미에 대해 설명할 필요가 있다.
- 엔터티 본문은 헤더 필드의 끝을 의미하는 빈 CRLF 줄 바로 다음부터 시작한다.

## 2. Content-Length: 엔터티의 길이

- Content-Length 헤더는 메시지의 엔터티 본문의 크기를 바이트 단위로 나타낸다. 메시지를 청크 인코딩으로 전송하지 않는 이상, 엔터티 본문을 포함한 메시지에서는 필수적으로 있어야 한다.
- 서버 충돌로 인해 메시지가 잘렸는지 감시하고자 할 때와 지속 커넥션을 공유하는 메시지를 올바르게 분할하고자 할 때 필요

### 2.1 잘림 검출

- Content-Length가 없으면 클라이언트는 커넥션이 정상적으로 닫힌 것인지 서버에 충돌이 발생한 것인지 구분하지 못한다. 따라서 메시지 잘림을 검출하기 위해 Content-Length를 필요로 한다.
- 메시지 잘림은 캐싱 프락시 서버에서 특히 취약하다. 캐시가 잘린 메시지를 수신했으나 잘렸다는 것을 인식하지 못한 경우, 캐시는 결함이 있는 콘텐츠를 저장하고 계속해서 제공하게 되므로 이를 방지하기 위해 캐싱 프락시 서버는 Content-Length 헤더를 갖고 있지 않은 HTTP 본문은 보통 캐시하지 않는다.

### 2.2 잘못된 Content-Length

- Content-Length가 잘못된 값을 담지 않도록 HTTP/1.1 사용자 에이전트는 잘못된 길이를 인지했을 때 사용자에게 알려주게 되어 있다.

### 2.3 Content-Length와 지속 커넥션(Persistent Connection)

- 지속된 커넥션을 위하여 Content-Length는 필수이고 지속된 커넥션 하에 커넥션이 닫힌 위치를 근거로 메시지의 끝을 인식하는 것은 불가능하다. 또한 HTTP 애플리케이션은 엔터니 본문과 다음 메시지의 구분을 하지 못한다.
- 청크 인코딩을 사용한 경우 엔터티 전체 크기를 알 수 없더라도 전송할 수 있다.

### 2.4 콘텐츠 인코딩

- HTTP 보안을 강화하거나 압축을 통해 공간을 절약 할 수 있도록, 엔터티 본문을 인코딩할 수 있게 한다. 콘텐츠가 인코딩이 된 경우, 원본 길이가 아닌 인코딩 후의 길이로 본문의 길이를 바이트 단위로 정의한다.

### 2.5 엔터티 본문 길이 판별을 위한 규칙

1. 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP메시지에서는 본문계산을 위한 Content-Length 헤더가 무시된다. 예를들어 HEAD 응답의 경우 본문을 갖지 않기에 반드시 헤더 이후의 첫번째 빈 줄에서 끝나야 한다.
2. Transfer-Encoding 헤더를 포함고 있으면 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 '0 바이트 청크'라 부르는 특별한 패턴으로 끝나야 한다.
3. Transfer-Encoding 헤더 필드를 갖고 있는 메시지를 받았다면 반드시 Content-Length 헤더를 무시해야 하는데, 전송 인코딩이 엔터티 본문을 표현하고 전송하는 방식을 바꿀 것이기 때문이다.
4. 'multipart/byteranges' 미디어 타입을 사용하는 멀티파트 유형은 스스로의 크기를 결정할 수 있는 유일한 엔터티 본문 유형이다.
5. 위 규칙에 해당되지 않으면 엔터티는 커넥션이 닫힐 때 끝나며 서버만이 커넥션을 닫을 수 있다.
6. HTTP/1.0 애플리케이션과 호환을 위해 엔터티 본문을 갖고 있는 HTTP/1.1 요청은 반드시 유효한 Content-Length 헤더도 갖고 있어야 한다.

## 3. 엔터티 요약

- 엔터티 본문 데이터에 대한 의도하지 않은 변경을 감지하기 위해, 최초 엔터티 생성시 송신자는 데이터에 대한 체크섬을 생성할 수 있고 수신자는 그 체크섬으로 기본적인 검사를 할 수 있다.
- 메시지의 무결성을 검증하려는 클라이언트는 먼저 전송 인코딩을 디코딩 한 뒤 그 디코딩 된 엔터티 본문에 대한 MD5 계산을 하여 검증을 한다.
- MD5는 문서의 위치를 알아내고 콘텐츠의 중복 저장을 방지하기 위한 해시 테이블의 키로 이용될 수 있다.

## 4. 미디어 타입과 차셋(Charset)

- Content-Type 헤더 필드는 엔터티 본문의 MIME 타입을 기술한다. 주 미디어 타입과 빗금, 구체적인 미디어 타입을 서술하는 부 타입으로 구성된다.
- 엔터티가 콘텐츠 인코딩을 거친 경우에도 Content-Type 헤더는 여전히 인코딩 전의 엔터티 본문 유형을 명시할 것이다.

### 4.1 텍스트 매체를 위한 문자 인코딩

- 엔터티의 비트 집합을 텍스트 파일의 글자들로 변환하기 위한 'charset' 매개변수는 Content-Type 헤더가 내용 유형을 더 자세히 지정하기 위한 대표적인 예이다.

### 4.2 멀티파트 미디어 타입

- MIME 멀티파트 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내진다. 각 구성요소는 자신을 서술하는 헤더를 포함하고 문자열 하나로 서로의 경계가 식별된다.

### 4.3 멀티파트 폼 제출

- HTTP 폼 제출 시, 텍스트 필드와 업로드 될 객체는 각각 멀티파트 본문을 구성하는 하나의 파트가 되어 보내진다.
- 멀티파트 본문은 여러 다른 종류/길이의 값으로 채워진 폼을 허용하는데, 이러한 경우 `Content-type: multipart/mixed` 또는 `Content-type: multipart/form-data` 헤더에 멀티파트 본문을 함께 보낸다.
  `Content-type: multipart/form-data; boundary=[abcdefghijk]`
- boundary는 본문의 서로 다른 부분을 구분하기 위한 구분자로 쓰인다.

### 4.4 멀티파트 범위 응답

- 범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수도 있다. 그런 응답은 Content-type: multipart/byteranges 헤더 및 각각 다른 범위를 담고 있는 멀티파트 본문이 함께 온다.

## 5. 콘텐츠 인코딩
- 서버, 즉 발송하는 쪽에서 전송시간 단축을 위한 압축, 콘텐츠 암호화를 위한 인코딩을 하고, 인코딩이 끝난 콘텐츠를 엔티티 본문에 담아 클라이언트에 보낸다.

### 5.1 콘텐츠 인코딩 과정
1. 웹서버가 원본 Content-Type과 Content-Length 헤더를 바탕으로 원본 응답 메세지를 생성한다.
2. 콘텐츠 인코딩 서버가 인코딩된 메세지를 생성한다. 인코딩된 메세지는 Content-Type은 같지만 Content-Length는 다를 수 있다. 콘텐츠 인코딩 서버는 Content-Encoding 헤더를 메세지에 추가해 클라이언트에서 디코딩할 수 있도록 한다.
3. 클라이언트는 인코딩된 메세지를 받아 디코딩해 원본 콘텐츠를 얻는다.

### 5.2 콘텐츠 인코딩 유형
- HTTP는 표준 인코딩 유형 + 확장 인코딩도 허용한다. (IANA : 인코딩 알고리즘에 고유한 토큰을 할당하는 IANA를 통해 표준화된다. ex. gzip, compress, deflate -> 무손실 압축 알고리즘, identity -> Content-Encoding 헤더가 없으면 어떤 인코딩도 수행되지 않았음을 의미한다. )

### 5.3 Accept-Encoding 헤더
- 클라이언트는 서버가 해독할 수 없는 방법으로 인코딩하지 않도록 클라이언트가 지원하는 인코딩 목록을 Accept-Encoding 요청 헤더에 , 로 구분해 전달한다.
- 헤더가 없을시 * 와 같이 어떤 인코딩도 허용하게 된다. q=0.0 ~ q=1.0 까지 선호도를 표시해 전달 할 수 있다.

## 6. 전송 인코딩과 청크 인코딩
- 콘텐츠 인코딩은 콘텐츠 포맷과 긴밀하게 연관되어 있다.
- 전송 인코딩 : 콘텐츠 인코딩과 다르게 콘텐츠의 포맷과 독립적이며, 메세지 데이터가 네트워크를 통해 전송되는 방법을 바꾸기 위해 전송 인코딩을 메세지에 적용할 수 있다. 콘텐츠 인코딩된 메세지는 엔티티 부분만 인코딩하는 반면, 전송 인코딩은 전체 메세지에 적용되어 메제시 자체의 구조를 바꾼다.

### 6.1 안전한 전송
- 전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 '안전한 전송'을 위해 존재해왔다. HTTP 전송된 메세지 본문에서 문제를 일으키는 것은 몇 가지 밖에 없는데, 그 중 두가지는 아래와 같다.
   - 알 수 없는 크기 : 몇몇 게이트웨이 앱과 콘텐츠 인코더는 콘텐츠를 생성하지 전에는 메제시 본문의 최종 크기를 판단할 수 없다. 몇몇 서버는 데이터의 끝을 알리는 CRLF을 포함시켜 전송 인코딩으로 데이터를 보내려 시도한다.
   - 보안 : 전송 인코딩으로 알아보기 어렵게 뒤섞어버리는 경우. 그러나 SSL과 같은 전송 계층 보안 방식으로 흔하게 발생하지는 않는다.
   
### 6.2 Transfer-Encoding 헤더
- Transfer-Encoding : 안전한 전송을 위해 어떤 인코딩이 메세지에 적용되었는지 클라이언트에 알려준다.
- TE : 어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에 알려주기 위해 요청 헤더에 사용한다. q값 사용 가능하나 HTTP/1.1명세에서는 0.0을 갖는 것을 금지한다.

### 6.3 청크 인코딩
- 청크 인코딩은 메세지를 일정 크기의 청크 여럿으로 쪼개고 서버는 각 청크를 순차적으로 보낸다. 
- 청크 인코딩을 이용하면 메세지를 보내기 전에 전체 크기를 알 필요가 없어지는데, 본문이 동적으로 생성됨면 서버는 그중 일부를 버퍼에 담은 뒤 한 청크를 그 크기와 함께 보낼 수 있다. 본문 전체를 모두 보낼 때까지 이 단계를 반복한다. 마지막 청크는 크기가 0이며, 이로써 본문이 끝났음을 알리고 다음 응답을 위해 커넥션을 열린 채로 유지할 수 있다.

#### 청크와 지속 커넥션
클라이언트와 서버 사이의 커넥션이 지속적이지 않다면, 클라이언트는 자신이 읽고 있는 본문의 크기를 알 필요가 없다. 서버가 커넥션을 닫을 때까지 본문으로 간주하고 읽을 것이다. 

#### 청크 인코딩된 메세지의 트레일러
다음 중 하나 이상의 조건을 만족하면 청크 메세지에 트레일러를 추가할 수 있다.
- 클라이언트의 TE헤더가 트레일러를 받아들일 수 있음을 나타내고 있는 경우
- 트레일러가 응답을 만든 서버에 의해 추가되었으며, 그 트레일러 콘텐츠가 클라이언트가 이해하고 사용할 필요가 없는 선택적인 메타데이터이므로 클라이언트가 무시하고 버려도 되는 경우
- 메세지 헤더는 청크 인코딩된 메세지 다음에 오게 될 헤더를 나열하는 트레일러 헤더를 포함한다.

### 6.4 콘텐츠와 전송 인코딩의 조합
- 콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다.

### 6.5 전송 인코딩 규칙
- 전송 인코딩의 집합은 반드시 'chunked'를 포함해야 한다. 유일한 예외는 메세지가 커넥션의 종료로 끝나는 경우.
- 청크 전송 인코딩이 사용되었다면, 메세지 본문에 적용된 마지막 인코딩이 존재해야 한다.
- 청크 전송 인코딩은 반드시 메세지 본문에 한 번 이상 적용되어야 한다.
이 규칙은 클라이언트가 메세지의 전송 길이를 알아낼 수 있게 해준다.

## 7. 시간에 따라 바뀌는 인스턴스
웹 객체는 정적이지 않다. 같은 URL은 시간에 따라 다른 버전의 객체(인스턴스)를 가리킬 수 있다. 
- HTTP 프로토콜은 특정 종류의 요청이나 응답을 다루는 방법들을 정의하는데, 이것을 인스턴스 조작이라 하며 객체의 인스턴스에 작용한다.
- ex. 범위 요청, 델타 인코딩 : 클라이언트가 자신이 갖고 있는 리소스 사본이 서버가 갖고 있는 것과 정확히 같은지 판단하고, 상황에 따라 새 인스턴스를 요청할수 있는 능력을 가질 것을 요구한다. 

## 8. 검사기와 신선도

- 조건부 요청은 클라이언트가 가지고 있는 리소스 버전을 서버에게 말해 검사기를 사용하여 사본 버전이 더 이상 유효하지 않을 때만 사본을 보내달라고 요청하는 것이다.

### 8.1 신선도

- 서버는 Expires 혹은 Cache-Control 헤더를 통해 얼마나 오래 캐시하고 신선하다고 가정할 수 있는 지 정보를 제공한다.
  - Expires: Sun Dec 31 23:59:59 GMT 2022
- Expires 헤더를 바르게 사용하는 클라이언트와 헤더는 반드시 시계를 동기화시켜야 한다. 그러나 네트워크 시간 프로토콜(Network Time Protocol, NTP)과 같은 시계 동기화 프로토콜을 실행하지 않았을 가능성이 있다.
- 따라서 Cache-Control 헤더는 문서의 최대 수명을 문서가 서버를 떠난 후로부터의 총 시간을 초 단위로 정한다. 이는 시계 동기화에 의존하지 않는다.

### 8.2 조건부 요청과 검사기

- 조건부 요청은 특정 조건이 참일 때만 수행되는 HTTP 요청 메시지이다. 조건부 헤더가 'if~' 로 시작하며 참이 아닐 경우 서버는 에러코드를 보낸다.
- 일련번호나 버전번호, 문서의 최종 변경일 같은 검사기를 이용하여 조건부 요청이 동작한다.

[조건부 요청 유형 4가지 헤더]
| 요청 유형 | 검사기 | 설명 |
| :-------------------: | :-------------: | :------------------------------------------------------------------------------------------------------------: |
| If-Modified-Since | Last-Modified | 지난 Last-Modified 응답 헤더에 들어있었던 시각에 마지막으로 수정된 버전이 최신 버전이 아니면 리소스 사본 요청 |
| If-Unmodified-Since | Last-Modified | 지난 Last-Modified 응답 헤더에 들어있었던 시각에 마지막으로 수정된 버전에서 변한 것이 없으면 리소스 사본 요청 |
| If-Match | ETag | 지난 ETag 응답 헤더의 엔터티 태그와 같으면 리소스 사본 요청 |
| If-None-Match | Etag | 지난 ETag 응답 헤더의 엔터티 태그가 다르면 리소스 사본 요청 |

- HTTP는 약한 검사기와 강한 검사기로 분류한다. 리소스의 인스턴스를 언제나 고유하게 식별하는 경우 강한 검사기, 그렇지 않은 경우도 있을 경우 약한 검사기이다. ex) 단순 콘텐츠 크기 비교와 암호 체크섬
- 최종 변경 시각은 리소스의 마지막 수정된 시각을 의미하지만, 1초에 수천 번의 요청을 처리하는 서버가 최종 변경이 발생했음을 항상 반영해주지 못하여 약한 검사기로 간주된다.
- ETag 헤더는 강한 검사기로, 서버가 ETag 헤더에 매 변경마다 구분되는 값을 넣기 때문이다.
- ETag 헤더로 버전 번호와 요약 체크섬 외에 텍스트 값을 가질 수 있다.
- 서버는 태그 앞에 'W/' 를 붙여 '약한' 엔터티 태그임을 표시하여 엔터티의 의미상 두드러진 변화에만 변경되도록 한다.

## 9. 범위 요청

- HTTP 클라이언트가 받다가 실패한 엔터티를 다운로드가 중단된 시점부터 받을 수 있도록 일부 혹은 범위요청을 할 수 있다.
- Range 헤더는 여러 범위 요청이 가능하다. ex) 하나의 문서에 대해 동시에 여러 서버에 접속하여 서로 다른 범위를 요청할 수 있다.
- 객체의 특정 인스턴스를 교환하기 때문에 클라이언트의 범위 요청은 서버와 같은 버전의 문서를 갖고 있을 때만 의미가 있다.

## 10. 델타 인코딩

- 델타 인코딩은 객체 전체가 아닌 변경된 부분에 대해서만 통신하여 전송량을 최적화하는 HTTP 프로토콜의 확장이다.
- 클라이언트와 서버 사이의 정보교환에 의존하는 일종의 인스턴스 조작이다.
  - 1. 클라이언트가 델타(변경된 부분)를 받아들일 의사가 있고 어떤 델타 적용 알고리즘을 알고 있는지 서버에게 알려준다.
  - 2. 서버는 클라이언트의 버전과의 체크 후 델타를 계산해서 클라이언트에게 보내주고, 서버가 델타를 보내고 있음을 알려준다. 최신 버전 식별자도 명시.
  - 3. 클라이언트는 가지고 있던 버전의 식별자(지난 응답의 ETag 헤더에 들어있던 식별자)를 If-None-Match 헤더에 담는다. 서버는 If-None-Match 헤더에 의해 최신 버전 전체를 보낸다.
  - 4. 클라이언트는 A-IM(Accept-Instance-Manipulation) 헤더를 서버에 보내서 델타를 받아들일 수 있음을 알려준다.
  - 5. 서버는 Delta-Base 헤더(226 IM Used, 델타 계산 알고리즘 IM 헤더, 새 ETag 헤더, 델타 계산 기반 문서의 ETag)를 되돌려 준다.
       ![델타 인코딩의 메커니즘](https://user-images.githubusercontent.com/74203440/209600078-9fe169e4-2daf-43f6-aa3c-457deebaf23e.png)

### 10.1 인스턴스 조작, 델타 생성기 그리고 델타 적용기

- 델타 인코딩은 전송 시간을 줄일 수 있지만 페이지가 변경되는 매 순간의 사본을 모두 유지하고 있어야 문서를 요청하는 서로 다른 클라이언트에게 변경점을 보낼 수 있다. 문서 제공에 걸리는 시간이 줄어드는 대신, 과거 사본을 모두 유지하기 위한 디스크 공간이 필요하다. 이로 인해 전송량 감소로 얻은 이득이 무의미해진다.
