## 14장 보안 HTTP

### 14.1 HTTP를 안전하게 만들기
- 웹은 안전한 방식의 HTTP를 필요로 하며 그에 따라 HTTP와 디지털 암호화 기술을 결합해 사용한다. 또한, 다음을 제공해 줄 수 있는 HTTP 보안 기술이 필요하다.
1. 서버 인증 - 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기하고 있음을 알 수 있어야 한다.
2. 클라이언트 인증 - 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기하고 있음을 알 수 있어야 한다.
3. 무결성 - 클라이언트와 서버는 그들이 데이터가 위조되는 것으로부터 안전해야 한다.
4. 암호화 - 클라이언트와 서버는 도청에 대한 걱정없이 서로 대화할 수 있어야 한다.
5. 효율 - 저렴한 클라이언트와 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 한다.
6. 편재성 - 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
7. 관리상 확장성 - 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
8. 적응성 - 현재 알려진 최선의 보안 방법을 지원해야 한다.
9. 사회적 생존성 - 사회의 문화적, 정치적 요구를 만족시켜야 한다.

- HTTPS는 HTTP를 안전하게 만드는 가장 인기있는 방식이다. 
- HTTPS를 사용할 때, 모든 HTTP 요청/응답 데이터는 네트워크로 보내지기 전에 암호화된다.
- HTTPS는 HTTP 하부에 전송레벨 암호보안 계층을 제공함으로써 동작한다. 이는 SSL(Secure Sockets Layer) 혹은 TLS(Transport Layer Security)를 이용해 구현된다.

### 14.2 디지털 암호학
- SSL 혹은 TLS에서 이용되는 암호 인코딩에 관한 배경지식
    - 암호 : 텍스트(평문)를 아무나 읽지 못하도록 인코딩하는 알고리즘
    - 키 : 암호의 동작을 변경하는 숫자로된 매개변수
    - 대칭키 암호 체계 : 인코딩/디코딩에 같은 키를 사용하는 알고리즘
    - 비대칭키 암포 체계 : 인코딩/디코딩에 다른 키를 사용하는 알고리즘
    - 공개키 암호법 : 비밀 메세지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템 -> (공개키 암호법으로 인해 많은 클라이언트가 안전한 트랜잭션을 할 수 있게 되었다.)
    - 디지털 서명 : 메세지가 위조, 변조되지 않았음을 입증하는 체크섬
    - 디지털 인증서 : 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보
- 암호법은 메세지를 암호화하는 것 뿐 아니라, 메세지 변조 방지, 메세지나 트랜잭션의 저자를 증명하는 데도 사용될 수 있다.
- 대부분의 암호 기계에는 암호의 동작방식을 변경할 수 있는 큰 숫자로 된 다이얼이 달려있다. 올바른 다이얼 설정(키 값)이 없이는 디코더가 동작하지 않을 것이다.
- 이런 암호 매개변수를 키라고 부르며, 올바른 디코딩을 하려면 올바른 키가 필요하고, 암호 키는 하나의 암호 기계를 여러 가상 암호 기계의 집합처럼 만들어준다. 
- 가상 암호 기계는 각각 다른 키를 가지면서 제각각 다르게 동작한다.
- * 실제로 기계의 로직을 알게되면 암호를 깨는데 도움이 되는 경우가 많은데, 현대 암호화 알고리즘은 대부분 키를 사용하며, 알고리즘이 공개적으로 알려져 있다고 하더라도 암호를 풀 패턴을 찾아내기 어렵도록 설계된다.

### 14.3 대칭키 암호법
- 대칭키 암호는 인코딩할때 사용한 키가 디코딩할 때와 같다. 
- 발송자와 수신자가 통신을 위해 비밀 키를 공유할 필요가 있고, 발송자는 공유된 키로 메세지를 암호화하고, 수신자는 암호문을 수신자에게 발송한다. 수신자는 암호문을 받은 뒤 공유된 키로 원래의 평문을 복원하기 위해 해독 함수를 적용한다.
- 비밀키가 누설되서는 안되며, 인코딩,디코딩 알고리즘은 대부분 공개적으로 알려져 있고 키만이 유일한 비밀이다.
- 좋은 암호 알고리즘은 우주에 존재하는 모든 키 값을 대입해보는 것 외에 해독할 다른 방법이 없게 만든다. 무차별로 모든 키 값을 대입해보는 공격을 열거 공격(enumeration attack)이라고 한다.
- 대칭키 암호의 단점은 발송자,수신자가 대화하기 위해 공유키를 가져야 한다는 것이다. 비밀키를 발급받고, 공유된 비밀키를 기억할 방법이 필요하다. 또한, 여러 발/수신자 사이의 키들을 각각 모두 기억해야한다.
(만약 n개의 노드가 있고, 각 노드가 상대n-1와 대화한다고 하면 대략 총 n^2개의 비밀키가 필요하며, 이는 관리하기 매우 어렵다.)

### 14.4 공개키 암호법
- 한 쌍의 호스트가 하나의 인코딩/디코딩 키를 사용하는 대신, 공개키 암호 방식은 두 개의 비대칭 키를 사용한다. 하나는 호스트의 메세지를 인코딩하기 위한 것, 다른 하나는 그 호스트의 메세지를 디코딩하기 위한 것이다.
- 인코딩 키는 모두를 위해 공개되어있다. 하지만 호스트만이 개인 디코딩 키를 알고 있다.
- 이로써 대칭 키의 쌍이 n^2로 폭발적으로 증가하는 것을 피할 수 있다.
- 공개키 암호화 기술은 보안 프로토콜을 전 세계의 모든 컴퓨터 사용자에게 적용하는 것을 가능하게 했다.
- 또한, 누구나 공개키만 알면 그 키에 대응되는 공개 서버에 안전하게 메세지를 보낼 수 있게 해주었으며 두 노드가 의사소통할 때 개인 키에 대한 협상을 먼저 할 필요가 없게 해주었다.
- 그러나 공개키 암호방식은 계산이 느린 경향이 있어, 실제로는 대칭과 비대칭 방식을 섞은 것이 사용된다. 
(노드들 사이의 의사소통 채널을 수립할 대는 공개키 방식을, 만들어진 안전한 채널을 통해 임시의 무작위 (빠른)대칭키를 생성,교환해 이후 나머지 데이터를 암호화해 사용한다.

### 14.5 디지털 서명 (digital signing)

- 암호 체계는 누가 메시지를 썼으며, 위조되지 않았다는 것을 증명하기 위한 서명의 용도도 있음
- 디지털 서명은 인터넷 보안 인증서에게 중요한 요소

#### 14.5.1 서명은 암호 체크섬이다

- 디지털 서명은 메시지에 붙어있는 특별한 암호 체크섬
- 2가지 이점
  - 메시지 작성자가 누군지 알려줌<br>저자의 극비 개인 키를 통해 저자만이 체크섬을 계산할 수 있게 함
  - 메시지 위조 방지<br>해커가 메시지를 수정하면 체크섬도 더이상 맞지 않게 될 것<br>체크섬은 비밀 개인 키와 관련되어 있으므로 해커는 체크섬을 날조할 수 없음
- 디지털 서명은 보통 비대칭 공개키에 의해 생성됨
  - 개인 키는 오직 소유자만 갖고 있으며, 일종의 '지문'처럼 사용됨

![해독된 디지털 서명](https://user-images.githubusercontent.com/75058239/207465365-fdcc84c4-8142-4943-bf90-a98bb2d038cf.png)

- 노드 A는 가변 길이 메시지를 정제하여 고정된 길이의 digest로 만듦
- 노드 A는 digest에 사용자의 개인 키를 매개변수로 하는 signature 함수 적용
  - signature 함수는 서명자가 소유자임을 확인
  - 디코더 함수 D를 사용하는 이유는 해당 함수가 사용자의 개인 키와 관련되어 있기 때문
- 서명 계산 이후 노드 A는 메시지 끝에 서명을 덧붙이고 노드 B에게 전송
- 노드 B는 메시지 작성자를 확인하기 위해 서명을 검사할 수 있음
  - 노드 B는 디지털 서명에 공개키를 이용한 역함수를 적용해서 발송자를 검증
  - 만약 풀어낸 요약이 노드 B가 가지고 있는 버전의 요약과 일치하지 않으면 중간에 위조되었거나 노드 A가 아니라는 뜻

<br>

### 14.6 디지털 인증서

- 인터넷의 신분증인 디지털 인증서는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있음
- 일상에서도 명함 같은 ID는 위조가 쉽지만,<br>여권 같은 ID는 서명, 정부가 새긴 도장, 특별한 종이 덕분에 위조가 어렵고, 그래서 높은 신뢰를 받음

#### 14.6.1 인증서의 내부

- 디지털 인증서에는 공식적으로 '인증 기관'에 의해 디지털 서명된 정보 집합이 담겨있음
- 디지털 인증서에 기본적으로 담기는 것들
  - 대상 이름 (사람, 서버, 조직 등)
  - 유효 기간
  - 인증서 발급자 (인증서 보증인)
  - 인증서 발급자의 디지털 서명

![일반적인 디지털 서명의 포맷](https://user-images.githubusercontent.com/75058239/207730501-effef0b2-5f9b-40e1-b88c-014781c1f251.png)

- 디지털 인증서는 대상을 위해 사용된 서명 알고리듬 및 서술 정보 뿐만 아니라 대상의 공개키도 가지고 있음
  - 누구나 디지털 인증서를 만들 수 있지만, 누구나 인증 정보를 보증하는 개인 키 서명 권한을 얻을 수 있는 것은 아님

#### 14.6.2 X.509 v3 인증서

- 디지털 인증서에 대한 세계적인 단일 표준은 없음
- 그러나 `X.509`라 불리는 표준화된 서식이 있음
- X.509 v3 인증서는 인증 정보를 파싱 가능한 **필드**에 넣어서 구조화하는 표준화된 방법 제공
- 오늘날 대부분의 디지털 인증서는 X.509 v3 구조를 따름

|           필드            | 서명                                                                                                                                                                             |
| :-----------------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|           버전            | 인증서가 따르는 X.509 인증서 버전 번호<br>요즘은 보통 버전 3                                                                                                                     |
|         일련번호          | 인증기관에 의해 생성된 고유한 정수<br>CA 인증서는 반드시 고유 일련번호를 가져야 함                                                                                               |
|     서명 알고리듬 ID      | 서명을 위해 사용된 암호 알고리듬<br>ex) "RSA 암호화를 이용한 MD2 요약"                                                                                                           |
|       인증서 발급자       | 인증서를 발급하고 서명한 기관 이름<br>X.500 포맷으로 기록                                                                                                                        |
|         유효 기간         | 인증서 유효 기간<br>시작일과 종료일로 정의됨                                                                                                                                     |
|         대상 이름         | 인증서에 기술된 사람이나 조직 등의 엔티티<br>X.500 포맷으로 기록                                                                                                                 |
|    대상의 공개키 정보     | 인증 대상의 공개키, 공개키에 사용된 알고리듬, 추가 매개변수                                                                                                                      |
| 발급자 고유 ID (optional) | 발급자 이름이 겹칠 때를 위한 고유 식별자                                                                                                                                         |
|  대상 고유 ID (optional)  | 대상 이름이 겹칠 때를 위한 고유 식별자                                                                                                                                           |
|           확장            | 선택적 확장 필드 집합<br>각 확장 필드는 중요한지 아닌지 표시됨<br>중요한 확장은 인증서 사용자에 의해 반드시 이해되어야 함<br>주로 사용되는 확장: 기본 제약, 인증서 정책, 키 사용 |
|       인증기관 서명       | 위 모든 필드에 대한 인증기관의 디지털 서명<br>명시된 서명 알고리듬 사용                                                                                                          |

- X.509 기반 인증서에는 웹 서버 인증서, 클라이언트 이메일 인증서, code-signing 인증서, 인증기관 인증서 등 여러 변종이 있음

#### 14.6.3 서버 인증을 위해 인증서 사용하기

- 사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 서버에서 디지털 인증서를 가져옴
  - 만약 서버에 인증서가 없다면 보안 커넥션은 실패
- 서버 인증서가 포함하는 필드들
  - 웹 사이트 이름 및 호스트명
  - 웹 사이트 공개키
  - 서명 기관 이름
  - 서명 기관 서명
- 브라우저는 인증서를 받고 서명 기관을 검사
  - 해당 기관이 신뢰할 만한 서명 기관이라면 브라우저는 해당 기관의 공개키를 이미 알고 있을 것
    - 브라우저들은 여러 서명 기관의 인증서가 미리 설치된 채로 출하됨

<img width="607" alt="디지털 서명 검증" src="https://user-images.githubusercontent.com/75058239/207730619-af116196-a44a-48b7-90a4-48024d4b5037.png">

- 만약 브라우저가 서명 기관을 모를 경우에는 대개 사용자가 서명 기관을 신뢰하는지 확인하기 위한 대화상자를 보여줌

<br>

### 14.7 HTTPS의 세부사항

- HTTPS는 HTTP의 가장 유명한 보안 버전
  - 주류 상용 브라우저 및 서버에 널리 구현되어 있음
- HTTPS는 HTTP 프로토콜에 대칭, 비대칭 인증서 기반의 강력한 암호 기법 집합을 결합한 것
  - 이 기법들의 집합은 무정부 상태의 글로벌 인터넷 환경에서도 HTTPS를 매우 안전하고 유연하고 관리하기 쉽게 만들어줌

※ HTTPS는 인터넷 애플리케이션의 성장 가속과 웹 기반 전자상거래 기술의 발전을 이끈 주력<br>또한 웹 애플리케이션의 광역 보안 관리에 있어서 대단히 중요

#### 14.7.1 HTTPS 개요

- HTTPS는 그냥 보안 전송 계층을 통해 전송되는 HTTP라고 보면 됨
  - HTTPS는 HTTP 메시지를 TCP로 보내기 전에 먼저 그것들을 암호화하는 보안 계층으로 보냄

![HTTP   HTTPS](https://user-images.githubusercontent.com/75058239/206882243-46eeed00-1988-4d5f-acfa-36443ab7f8bd.png)

- 오늘날 HTTPS의 보안 계층은 SSL과, SSL의 현대적 대체품인 TLS로 구현되어 있음
  - SSL과 TLS 모두를 의미하는 단어로 'SSL'을 사용하는 관행이 있음

#### 14.7.2 HTTPS 스킴

- 보안 HTTP는 optional이기 때문에, 우리가 HTTP 보안 프로토콜 버전을 수행한다고 말해줄 방법이 필요
- 이는 URL의 scheme을 통해 이루어짐
  - `http://` 대신 `https://`를 사용하면 됨
- 클라이언트는 웹 리소스에 대한 트랜잭션 수행 요청을 받으면 URL의 스킴을 검사
  - 만약 URL이 http 스킴을 갖고 있다면, 서버와 80 포트로 연결하고, 평범한 HTTP 명령 전송
  - 만약 URL이 https 스킴을 갖고 있다면, 서버와 443 포트로 연결하고,<br>binary 포맷으로 된 몇몇 SSL 보안 매개변수를 교환하며 'handshake'를 하고, 암호화된 HTTP 명령 전송
- SSL 트래픽은 binary 프로토콜이기 때문에, HTTP와 완전 다름
  - 그렇기 때문에 보통 SSL에서 사용하는 443 포트로 전송됨

#### 14.7.3 보안 전송 셋업

![HTTP와 HTTPS 트랜잭션](https://user-images.githubusercontent.com/75058239/207986874-eacd7800-9a98-45cb-b381-e8ba87b6eab4.png)

HTTP의 절차

- 클라이언트는 웹 서버의 80 포트로 TCP 커넥션을 엶
- 요청 메시지를 보내고, 응답 메시지를 받음
- TCP 커넥션을 닫음

HTTPS의 절차

- 클라이언트는 웹 서버의 443 포트로 TCP 커넥션을 엶
- 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층 initialize
- handshake를 통한 초기화 작업 후, 클라이언트는 요청 메시지를 보안 계층에 전송
  - 요청 메시지는 TCP로 보내기 전에 암호화
- 서버는 요청 메시지를 복호화해서 받아들임
- 이후 서버 또한 응답 메시지를 암호화해서 TCP를 통해 전송
- 클라이언트는 응답 메시지를 복호화해서 받아들임
- SSL이 닫히고, TCP 커넥션도 닫힘

#### 14.7.4 SSL 핸드셰이크

암호화된 HTTP 메시지 전송 이전에, 클라이언트와 서버는 SSL handshake를 해야 함!

※ handshake에서 일어나는 일들

- 프로토콜 버전 번호 교환
- 양쪽이 아는 암호 선택
- 양쪽 신원 인증
- 채널을 암호화하는 임시 세션 키 생성

<img width="543" alt="SSL 핸드셰이크 단순화 버전" src="https://user-images.githubusercontent.com/75058239/208202195-1db0ceb2-0bf1-492b-8094-e2b2560f8dd3.png">

- SSL이 어떻게 사용되느냐에 따라 handshake는 보다 복잡해질 수 있음

#### 14.7.5 서버 인증서

- SSL의 상호 인증 지원: 서버 인증서를 클라이언트로, 클라이언트 인증서를 서버로 전송해줌
  - 그러나 오늘날 클라이언트 인증서는 웹 브라우징에서 잘 안 쓰임
  - 대부분의 사용자가 개인 클라이언트 인증서를 가지고 있지도 않음
  - 웹 서버에서 클라이언트 인증서를 요구하는 일도 많이 없어졌음
- 보안 HTTPS는 항상 서버 인증서를 요구
  - 인터넷 뱅킹에 접속하는 등 보안 트랜잭션을 수행할 때, 사용자는 대화하고 있는 서버가 어떤 서버인지 알고 싶어할 것
  - 잘 알려진 인증기관에 의해 서명된 서버 인증서는 서버가 얼마나 신뢰할 수 있는지 알게 해줌
- 서버 인증서: 조직 이름, 주소, 서버 DNS 도메인 이름 등을 보여주는, X.509 v3에서 파생된 인증서

#### 14.7.6 사이트 인증서 검사

- SSL 자체는 사용자에게 웹 서버 인증서 검증을 요구하지 않음
- 반면 최신 웹 브라우저들 대부분은 인증서에 대해 기본적인 검사를 수행
  - 검사 결과와 함께 더 철저하게 검사할 수 있는 방법을 사용자에게 알려줌

※ 넷스케이프가 제안한 웹 서버 인증서 검사 알고리듬

**날짜 검사**

- 브라우저는 인증서의 시작일 및 종료일을 검사
- 시작일과 종료일 사이가 아니라면 인증서 검사는 실패하고 브라우저는 에러를 출력

**서명자 신뢰도 검사**

- 모든 인증서는 CA(Certificate Authority)에 의해 서명되어 있음
- 수준별로 다른 인증서가 있으며, 각기 다른 배경 검증을 요구
  - 예를 들어 전자상거래 서버 인증서를 발급받고자 한다면, 사업체 법인에 대한 법적 증명 제시 필요
- 브라우저는 신뢰할 만한 서명 기관 목록을 포함한 채로 배포됨
  - 만약 목록에 없는 인증기관의 인증서를 받았다면 보통 경고를 표시함
- 브라우저는 또한 신뢰할 만한 CA가 간접적으로 서명한 인증서를 받아들이도록 선택할 수 있음

**서명 검사**

- 서명 기관이 믿을 만하다고 판단되었을 때,
  - 브라우저는 서명 기관의 공개키를 서명에 적용
  - 체크섬과 비교해보면서 인증서의 무결성 검사

**사이트 신원 검사**

- 인증서 복사 및 탈취를 방지하기 위해, 브라우저들은 인증서 도메인 이름이 서버 도메인 이름과 동일한지 비교
- 서버 인증서에는 보통 단일 도메인 이름이 들어있음
  - 하지만 몇몇 CA는 서버 클러스터나 서버 팜을 위해 서버 이름 목록이나 서버 이름들에 대한 와일드카드 표현을 담은 인증서를 만듦
- 호스트 명이 인증서 신원과 맞지 않는다면 클라이언트는 반드시 사용자에게 알리거나 에러와 함께 커넥션을 끊어야 함

#### 14.7.7 가상 호스팅과 인증서

- 하나의 서버로 여러 호스트 명을 갖고 있는 가상 호스팅의 경우, 보안 트래픽을 다루기 까다로울 수 있음
- 몇몇 인기 있는 웹 서버 프로그램은 오직 하나의 인증서만 지원


### 14.8 진짜 HTTPS 클라이언트

##### 14.8.1 OpenSSL
SSL과 TLS의 가장 인기있는 오픈소스 라이브러리. 

##### 14.8.2 간단한 HTTPS 클라이언트

1.  SSL 라이브러리 초기화
2.  서버의 호스트명의 IP 주소로 변환
3.  서버의 443 포트로 TCP 커넥션 형성
4.  TCP 커넥션을 통해 SSL 핸드쉐이크
5.  핸드쉐이크 완료, SSL을 통해 HTTP 요청 전송
6.  SSL 스택에서 HTTP 응답 읽기
7.  커넥션 닫기

##### 14.8.3 우리의 단순한 OpenSSL 클라이언트 실행하기



### 14.9 프락시를 통한 보안 트래픽 터널링

- 클라이언트가 서버로 보낼 데이터를 암호화 했기 때문에 프록시는 HTTP 헤더를 읽을 수 없고, HTTP 헤더를 읽을 수 없으면 요청을 어디로 보내야 하는지 알 수 없다.
- HTTPS와 프록시가 잘 동작하기 위해서 클라이언트가 프록시에게 어디와 접속하는지 알려주는 방법을 수정해야 한다.
- HTTPS SSL 터널링 프로토콜을 사용하여 연결 가능
	- 클라이언트는 프록시에게 연결하고자하는 호스트와 포트를 알려주고
	- 클라이언트는 프록시가 읽을 수 있도록 암호화 전에 평문으로 알려준다.
	- `CONNECT` 확장 메소드를 사용해서 평문으로 된 종단 정보를 전달해 프락시에게 호스트와 포트 연결을 요구하고 프록시는 터널을 생성해줌
```http
CONNECT home.netscape.com:443 HTTP/1.0
User-agent: Mozilla/1.1N

<핸드셰이크 성공 이후 SSL로 암호화 된 데이터가 이 다음에 온다.>
```

